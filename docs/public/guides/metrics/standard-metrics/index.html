<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Standard Metrics | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Understanding the standard metrics available in every NoSQLBench driver" name=description><link href=https://docs.nosqlbench.io/guides/metrics/standard-metrics/ rel=canonical><meta content=https://docs.nosqlbench.io/guides/metrics/standard-metrics/ property=og:url><meta content=https://docs.nosqlbench.io/guides/metrics/standard-metrics/ name=twitter:url><meta content="Understanding the standard metrics available in every NoSQLBench driver" property=og:description><meta content="Understanding the standard metrics available in every NoSQLBench driver" name=twitter:description><meta content="Standard Metrics | NoSQLBench Documentation" property=og:title><meta content="Standard Metrics | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/guides/metrics/standard-metrics/>Standard Metrics</a></h1><p>NoSQLBench comes with a set of standard metrics that are part of every driver. Each driver enhances the metrics available by adding their own metrics with the NoSQLBench APIs. This section explains what the standard metrics are, and how to interpret them.<h2 id=read-input>read-input</h2><p>Within NoSQLBench, a data stream provider called an <em>Input</em> is responsible for providing the actual cycle number that will be used by consumer threads. Because different <em>Input</em> implementations may perform differently, a separate metric is provided to track the performance in terms of client-side overhead. The <strong>read-input</strong> metric is a timer that only measured the time it takes for a given activity thread to read the input value, nothing more.<h2 id=strides>strides</h2><p>A stride represents the work-unit for a thread within NoSQLBench. It allows a set of cycles to be logically grouped together for purposes of optimization â€“ or in some cases â€“ to simulate realistic client-side behavior over multiple operations. The stride is the number of cycles that will be allocated to each thread before it starts iterating on them.<p>The <strong>strides</strong> timer measures the time each stride takes, including all cycles within the stride. It starts measuring time before the cycle starts, and stops measuring after the last cycle in the stride has run.<h2 id=cycles>cycles</h2><p>Within NoSQLBench, each logical iteration of a statement is handled within a distinct cycle. A cycle represents an iteration of a workload. This corresponds to a single operation executed according to some statement definition.<p>The <strong>cycles</strong> metric is a timer that starts counting at the start of a cycle, before any specific activity behavior has control. It stops timing once the logical cycle is complete.<h2 id=cycles-servicetime>cycles.servicetime</h2><p>Each cycle of an activity has a metric which measures its internal service time, measured from the moment the cycle starts processing to the moment is fully complete. This is provided<p>When rate limiters are used, this sub-name identifies the <em>service time</em> component as<h2 id=cycles-waittime>*cycles.waittime</h2><p>When a rate limiter is used, the waittime metric captures the notion of scheduling delay with respect to the requested rate. For example, if you specify a rate of 10 Kops/S, but at the 20 second mark, only 190Kops have completed, this represents one second of scheduling delay (10 Kops worth of operations at 10 Kops/S = 1 second). The cycles.waittime metric would thus indicate ~ 1S worth of waittime as the workload <em>falling behind by about 1 second</em>, although it would report in nanos.<h2 id=cycles-responsetime>*cycles.responsetime</h2><p>When a rate limiter is used, the responsetime metric combines the servicetime and waittime values to yield a computed responsetime. This is a measure of how long a user would have had to wait for an operation to complete based on some ideal schedule, as described by a rate limiter. In this way, a rate limiter acts as both a minimal and a maximal target. It is presumed that the composed system is fast enough to run at the limited rate, thus any slow-downs which cause the system to run effectively behind schedule represent a user-impacting effect.<h2 id=result>result</h2><p>ðŸ‘‰ This metric is provided directly by drivers. All conforming driver implementations should provide this metric as described below.<p>Each operationâ€™s execution is tracked with the <code>result</code> timer. This timer is used to measure <strong>ALL</strong> operations, even those with errors.<h2 id=result-success>result-success</h2><p>ðŸ‘‰ This metric is provided directly by drivers. All conforming driver implementations should provide this metric as described below.<p>For operations which completed successfully with no exception, a separate <code>result-success</code> timer is used. When your workload is running well, both the <code>result</code> and <code>result-success</code> timer count the same number and rate of operations. This provides a useful cross-check between metrics.<h2 id=error>*-error</h2><p>ðŸ‘‰ This metric is provided directly by drivers. All conforming driver implementations should provide this metric as described below. This happens automatically when the standard error handler implementation is used.<p>When the error handler sees an exception, the name of the exception is converted to a metric name with <code>-error</code> as the suffix. There will be one of these metric names created for each unique exception that occurs within an activity.</article></main><footer><div class=c><nav class=tpad><div></div></nav><p>Â© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>