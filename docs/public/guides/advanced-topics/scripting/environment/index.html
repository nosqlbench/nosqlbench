<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Scripting Environment | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Understanding the NoSQLBench JavaScript runtime environment" name=description><link href=https://docs.nosqlbench.io/guides/advanced-topics/scripting/environment/ rel=canonical><meta content=https://docs.nosqlbench.io/guides/advanced-topics/scripting/environment/ property=og:url><meta content=https://docs.nosqlbench.io/guides/advanced-topics/scripting/environment/ name=twitter:url><meta content="Understanding the NoSQLBench JavaScript runtime environment" property=og:description><meta content="Understanding the NoSQLBench JavaScript runtime environment" name=twitter:description><meta content="Scripting Environment | NoSQLBench Documentation" property=og:title><meta content="Scripting Environment | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/guides/advanced-topics/scripting/environment/>Scripting Environment</a></h1><p>NoSQLBench may look like a simplistic runtime for the casual user. This is quite intentional. Yet, a serious amount of expressive power lies just below the surface for the adventuring tester.<h2 id=dynamic-parameters>Dynamic Parameters</h2><p>Dynamic parameters are control variables which, when assigned to, cause an immediate change in the behavior of the runtime. Driver implementors have the option to make changes to activity parameters reactive within the driver. These parameters are thus able to respond to direct changes from within the scenario script. Additionally, some core parameters are dynamic.<h2 id=global-variables>Global Variables</h2><h4 id=scenario>scenario</h4><p>This is the <strong>Scenario Controller</strong> object which manages the activity executors in the runtime. All the methods on this Java type are provided to the scripting environment directly.<h3 id=activity-parameters>Activity Parameters</h3><h4 id=activities-alias-paramname>activities.&LTalias>.&LTparamname></h4><p>Each activity parameter for a given activity alias is available at this name within the scripting environment. Thus, you can change the number of threads on an activity named foo (alias=foo) in the scripting environment by assigning a value to it as in <code>activities.foo.threads=3</code>. Any assignments take effect synchronously before the next line of the script continues executing.<h4 id=metrics-alias-metric-name><strong>metrics</strong>.&LTalias>.&LTmetric name></h4><p>Each activity metric for a given activity alias is available at this name. This gives you access to the metrics objects directly. Some metrics objects have also been enhanced with wrapper logic to provide simple getters and setters, like <code>.p99ms</code> or <code>.p99ns</code>, for example.<p>Interaction with the NoSQLBench runtime and the activities therein is made easy by the above variables and objects. When an assignment is made to any of these variables, the changes are propagated to internal listeners. For changes to <em>threads</em>, the thread pool responsible for the affected activity adjusts the number of active threads (AKA slots). Other changes are further propagated directly to the thread harnesses and components which implement the ActivityType.<p><strong>WARNING:</strong> Assignment to the <em>workload</em> and <em>alias</em> activity parameters has no special effect, as you can’t change an activity to a different driver once it has been created.<p>You can make use of more extensive Java or Javascript libraries as needed, mixing then with the runtime controls provided above.<h2 id=enhanced-metrics-for-scripting>Enhanced Metrics for Scripting</h2><p>The metrics available in NoSQLBench are slightly different than the standard kit with dropwizard metrics. The key differences are:<h3 id=hdr-histograms>HDR Histograms</h3><p>All histograms use HDR histograms with <em>four</em> significant digits.<p>All histograms reset on snapshot, automatically keeping all data until you report the snapshot or access the snapshot via scripting. (see below).<p>The metric types that use histograms have been replaced with nicer version for scripting. You don’t have to do anything differently in your reporter config to use them. However, if you need to use the enhanced versions in your local scripting, you can. This means that Timer and Histogram types are enhanced. If you do not use the scripting extensions, then you will automatically get the standard behavior that you are used to, only with higher-resolution HDR and full snapshots for each report to your downstream metrics systems.<h3 id=scripting-with-delta-snapshots>Scripting with Delta Snapshots</h3><p>For both the timer and the histogram types, you can call getDeltaReader(), or access it simply as &LTmetric>.deltaReader. When you do this, the delta snapshotting behavior is maintained until you use the deltaReader to access it. You can get a snapshot from the deltaReader by calling getDeltaSnapshot(10000), which causes the snapshot to be reset for collection, but retains a cache of the snapshot for any other consumer of getSnapshot() for that duration in milliseconds. If, for example, metrics reporters access the snapshot in the next 10 seconds, the reported snapshot will be exactly what was used in the script.<p>This is important for using local scripting methods and calculations with aggregate views downstream. It means that the histograms will match up between your local script output and your downstream dashboards, as they will both be using the same frame of data, when done properly.<h3 id=histogram-convenience-methods>Histogram Convenience Methods</h3><p>All histogram snapshots have additional convenience methods for accessing every percentile in (P50, P75, P90, P95, P98, P99, P999, P9999) and every time unit in (s, ms, us, ns). For example, getP99ms() is supported, as is getP50ns(), and every other possible combination. This means that you can access the 99th percentile metric value in your scripts for activity <em>foo</em> as _ metrics.foo.cycles.snapshot.p99ms_.<h2 id=control-flow>Control Flow</h2><p>When a script is run, it has absolute control over the scenario runtime while it is active. Once the script reaches its end, however, it will only exit if all activities have completed. If you want to explicitly stop a script, you must stop all activities.<h2 id=strategies>Strategies</h2><p>You can use NoSQLBench in the classic form with <code>run driver=&LTactivity_type> param=value ...</code> command line syntax. There are reasons, however, that you will sometimes want to customize and modify your scripts directly, such as:<ul><li>Permute test variables to cover many sub-conditions in a test.<li>Automatically adjust load factors to identify the nominal capacity of a system.<li>Adjust rate of a workload in order to get a specific measurement of system behavior.<li>React to changes in test or target system state in order to properly sequence a test.</ul><h2 id=script-input-output>Script Input & Output</h2><p>Internal buffers are kept for <em>stdin</em>, <em>stdout</em>, and <em>stderr</em> for the scenario script execution. These are logged to the logfile upon script completion, with markers showing the timestamp and file descriptor (stdin, stdout, or stderr) that each line was recorded from.</article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>