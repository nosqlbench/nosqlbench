<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Performance Concepts | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Fundamental concepts for performance characterization" name=description><link href=https://docs.nosqlbench.io/guides/testing/performance-factoring/concepts/ rel=canonical><meta content=https://docs.nosqlbench.io/guides/testing/performance-factoring/concepts/ property=og:url><meta content=https://docs.nosqlbench.io/guides/testing/performance-factoring/concepts/ name=twitter:url><meta content="Fundamental concepts for performance characterization" property=og:description><meta content="Fundamental concepts for performance characterization" name=twitter:description><meta content="Performance Concepts | NoSQLBench Documentation" property=og:title><meta content="Performance Concepts | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/guides/testing/performance-factoring/concepts/>Performance Concepts</a></h1><h1 id=key-terms>Key Terms</h1><h2 id=operational-systems>Operational Systems</h2><p>When a system has no headroom, it is unable to be responsive during hardware or infrastructure outages, load spikes, changes in system topology, capacity scaling activities, other administrative activities like external backups.<p>User-facing systems are more often operational systems, which require a degree of built-in headroom in order to absorb load spikes or events described above. These systems are designed and tuned more for operational responsiveness and resiliency under load and workload changes. They are also combined with other less-operational designs as a fronting layer to absorb and manage around limitations in classic system designs.<p>Measuring the capacity of operational system without putting its operational headroom and responsiveness in focus is usually meaningless. We often measure the capacity of such systems as a <em>reference point</em> within which other, more realistic measurements may be taken.<h2 id=saturating-throughput>Saturating Throughput</h2><p>The throughput at which a system is fully utilizing its most critical resource and can go no faster. This is a measure of how much work a system is capable of. When a system is saturated, you will see the highest response times. This is typically measured in ops per second, sometimes abbreviated as “ops/s”, “Kops/s”, or just simply “Kops”.<h2 id=operational-headroom>Operational Headroom</h2><p>At saturating throughput, a system has no operational headroom. Operational headroom is the fraction of system capacity (throughput) which remains in reserve to handle load spikes, topology changes, hardware failures, external backup loads, and so on.<h2 id=nominal-throughput>Nominal Throughput</h2><p>A production-like workload in an operational system is one which takes into account the operational headroom that it would normally be run with in production. This is absolutely essential in how findings are presented so that users and operators make safe choices about system sizing, tuning, and so on. Case in point: If you ran a cluster at 100% of its saturating capacity, it would not be able to absorb a node outage without affecting the load. The load (user-facing workload, ostensibly) would be compromised in some way, from a lowered aggregate capacity, which would also likely result in significantly higher response times. Systems which are affected by over-saturation in this way are often much more severely affected than new operators would expect, due to the combination of service time and capacity effects stacking in an unhealthy way. This is easy to demonstrate in practice, and made more lucid through the lens of <a href=https://en.wikipedia.org/wiki/Little%27s_law rel=noopener target=_blank>Little’s law</a>.<p>Thus, a key insight about operational systems is that they need to be deployed and tested with <em>operational headroom</em> as explained above. A typical approach for testing a distributed system with built-in fault management capabilities would be to characterize its saturation throughput and then factor in headroom depending on the topology of the system. For a 5 node cluster, 70% throughput is a reasonable starting point.<h2 id=end-to-end-testing>End-to-End Testing</h2><p>To accurately gauge how a system performs (operationally) or behaves (functionally), you can either test it piece-wise – subsystem by subsystem, or you can test it fully assembled in an integrated fashion. An end-to-end test takes this further to include the composed system from the end-user, access pathways and infrastructure, and all internal services or endpoints that the system under test may depend on. End-to-end testing comes with a few key trade-offs:<ol><li>End-to-end testing provides the most coverage of any type of test. As such, it is often one of the first ways an operational system is tested in order to determine whether the system as a whole is operating and functioning correctly.<li>End-to-end testing does not provide a destructured of the system. It doesn’t focus the user’s on the element which may be causing a test failure. Further analysis is required to figure out why errors occur. <ul><li>In the very best system designs, failure modes manifest with specific reasons for why an error occurred, and specific details about where in the system it occurred. This does not carry over to performance testing very well.<li>Further, many systems intentionally obscure internal details for reasons of security or decoupling user experience from system details. This is common with cloud services for example.</ul><li>End-to-end testing is a form of integration testing, where potentially large deployments or configurations are required in order to facilitate testing activities. This leaves a larger surface area for misconfiguration which is incongruent with prod or customer specific details. Where these deployment manifests may diverge from actual customer systems, results may be invalid, in the form of false-positives or false-negatives.<li>Testing end-to-end on real systems is feasible with the right supporting test apparatus and path addressing methods, such as multi-tenant features of a system. However, doing this reliably and accurately requires the provisioning and auditing logic for testing systems to be one and the same as what customers or operators use in order to ensure that there is no difference between what is tested and what is intended to be tested.<li>Physical topology and logical pathing are not always visible or explicitly addressable from the testing apparatus, meaning that testing a whole system across all flows may be impossible without special routing or flagging logic in testing operations. If these are not in-built mechanisms in the user-facing functionality, then it creates a side-path which breaks system coverage guarantees. This makes some end-to-end test scenarios probabilistic, in that physical traversal paths may only be hit a fraction of the time.</ol><h2 id=scaling-math>Scaling Math</h2><p>In distributed systems testing, a common misconception is that you have to test your production loads at the same level as you would run them in production. This flies in the face of the design principles of linearly scalable systems. What is more important is that the effects of proportionality and congruence hold, in a durable way, so that observations on smaller systems can be used to make reliable predictions of larger systems. The methods used to do this are often described as <em>scaling math</em> in the NoSQLBench user community.<p>For example, suppose you have a workload that supports a line of business, a peak capacity requirement. With a provable presumption of linear scalability over nodes, you can do a test with 5 nodes which will provide the baselines measurements needed to project node requirements for any given throughput. This example doesn’t include the latency, but it can be extended to that once the throughput requirements are understood.<p>In fact, the principles and specific mechanisms of scale should be the key focus of any such studies. Once these are established as trust-worthy, further predictions or analysis become much easier.<p>Detailed examples with latency factors included will be given elsewhere.</article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>