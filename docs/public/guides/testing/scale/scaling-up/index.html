<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Scaling Up Testing | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="A blueprint for incremental scale-up testing methodology" name=description><link href=https://docs.nosqlbench.io/guides/testing/scale/scaling-up/ rel=canonical><meta content=https://docs.nosqlbench.io/guides/testing/scale/scaling-up/ property=og:url><meta content=https://docs.nosqlbench.io/guides/testing/scale/scaling-up/ name=twitter:url><meta content="A blueprint for incremental scale-up testing methodology" property=og:description><meta content="A blueprint for incremental scale-up testing methodology" name=twitter:description><meta content="Scaling Up Testing | NoSQLBench Documentation" property=og:title><meta content="Scaling Up Testing | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/guides/testing/scale/scaling-up/>Scaling Up Testing</a></h1><p>This is a simple high-level overview of <em>a</em> scale-up testing method, for those who are new to it and need a basic blueprint.<p>Testing for scale is often a complicated business. Often, users think that it is too expensive because a test at scale requires many systems. This is a not often the case. You can establish the relationships between testing resources and results on any scale. Further, you can establish the character of scalability at small scales at first and then go from there. This is often the best approach in terms of incremental results.<h2 id=start-small>Start Small</h2><p>When testing for scale, it is useful to establish your testing method at some arbitrarily small size of system and go from there. This allows you to prove out your testing apparatus and target system configuration in an affordable and easier-to-manage way. While a small system may not show you the <em>scaled up</em> performance that you want to measure, it gives you the first reference point you need in order to verify <em>how</em> a system scales.<h2 id=select-key-metrics>Select Key Metrics</h2><p>You can only establish the character of scaling by plotting multiple points between an independent and a dependent variable. At the highest level, the independent variable is “hardware” from a system scaling perspective, and “investment” from an TCO perspective. Most users will need to focus on how much hardware is needed to meet a given performance requirement, SLA, or throughput (or both). You must know the fundamental questions you are asking for the test to be framed and represented properly.<p>Metrics which are most often used include:<ul><li>response time, one of (or all of) <ul><li>p99 response time (historically called <em>latency</em>, but see the timing terminology reference)<li>read-specific p99 response time, as read patterns in systems are often much more indicative of overally scaling character</ul><li>Dataset Size<li>Saturating throughput<li>p99 response time at some nominal throughput<li>data density</ul><h2 id=nominal-vs-saturating-throughput>Nominal vs. Saturating throughput</h2><p>Operational systems are not run in production at 100% utilization. As an <em>operational system</em>, properly managed, they will be deployed to scale over the demand with some added headroom. This headroom is crucial to allow for self-healing or administrative events at the control plane layer while maintaining the workload at some acceptable level (throughput and latency).<p>Realistic measurement of a production-like system in depends on knowing both what throughput that system is capable of and how it responds at a realistic loading level. Running a system in production at 10% utilization is not cost-effective. Conversely, running a system at 99% utilization is not effective for maintaining availability through variable load, hardware failures, or administrative actions. So how do you find the level of throughput to test at?<p>A basic recipe consists of:<ol><li>Run the workload at a reasonable concurrency and no rate throttling and measure the <em>saturating</em> throughput.<li>Select a proportional loading level which represents what you would do in production. For example, for a headroom of 30%, you might select a loading level of 70%<li>Run your main workload at the proportional rate using client-side rate-limiting, and take your response time measurements from this run.</ol><h2 id=scale-up>Scale Up</h2><p>Once you have established your metrics at nominal throughput on your baseline system, you are ready to scale up your test. For the scaling mode that you are testing, change an independent variable (add a node, add cores, or whatever constitutes a <em>resource</em> in your target system).<p>Repeat the test flow above with a different set of parameters. Once you get two sets of results, you have enough to start characterizing scalability.<p>In general, distributed systems which are designed to scale focus on maintaining a given response time character when the proportion of resources is congruent to the rate of requests. Other scaling modes are available, but details vary by system, so be clear about what you are testing and why.<h2 id=explain-your-results>Explain Your Results</h2><p>It is crucial that you frame the fundamental premise of your test in any results.<p>This includes key details, like:<ul><li>What questions you aim to answer - What is the purpose of the test?<li>A high-level outline of the testing method or workflow used.<li>Details on how metrics are measured (see <a href=https://docs.nosqlbench.io/guides/testing/scale/scaling-up/vantage-points.md>Vantage Points</a>)<li>The basic formulae (like the nominal vs saturating rates above)<li>a direct and uncomplicated visual about the fundamental relationship between the test parameters<li>Full details of the system and workload used for testing. Even if you don’t provide this up-front it has to be readily available when asked for any result to be taken seriously.</ul></article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>