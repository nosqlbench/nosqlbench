<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Client Sizing | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="How to size your test clients to avoid bottlenecks" name=description><link href=https://docs.nosqlbench.io/guides/testing/scale/client-sizing/ rel=canonical><meta content=https://docs.nosqlbench.io/guides/testing/scale/client-sizing/ property=og:url><meta content=https://docs.nosqlbench.io/guides/testing/scale/client-sizing/ name=twitter:url><meta content="How to size your test clients to avoid bottlenecks" property=og:description><meta content="How to size your test clients to avoid bottlenecks" name=twitter:description><meta content="Client Sizing | NoSQLBench Documentation" property=og:title><meta content="Client Sizing | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/guides/testing/scale/client-sizing/>Client Sizing</a></h1><p>How do you know what kind of client to run? How do you know how many clients to run? How do you see the result of running multiple clients? We attempt to answer these questions below.<h2 id=testing-asymmetry>Testing Asymmetry</h2><p>When you are measuring system performance, certain precautions have to be taken in order to ensure that you are measuring what you intend. One of the most fundamental requirements is that the systems that generate load and measure results must be inherently more capable of scale than the system you are measuring. In other words, if the testing system is the bottle-neck in the composed system, then you are effectively measuring your testing system and not the target.<p>This is a sliding scale. For instance, if your testing system’s resources are <em>mostly</em> saturated, say “80% utilized”, then you are likely still leaving some performance untapped, or at the very least, measuring higher response times than you would otherwise. This follows from the fact that clients are not real-time systems and must juggle threads and other parallel computing resources in order to service results from the target system. There is no simple or practical way to avoid this.<p>So, in order to have empirical results which are accurate with respect to the target of your tests, your client resources must not be over-utilized. In most cases, a client which uses less than 60% of its CPU and is not otherwise throttled by resource contention will provide generally accurate results.<p>In some testing systems, such as those which pipe around data in order to replay operations, you will find that it is more difficult to scale your client nodes up than with NoSQLBench. That is because moving serialized operations around and then consuming them in real time is simply much more work on the client system. This forces you into a situation where the load bank needs to be much larger to offset processing demands in the testing apparatus. Methods involving local IO or pre-processing will generally be much slower than those which operate almost entirely within the CPU-Memory complex. NoSQLBench’s approach to synthesizing operations from recipes avoids much of this concern, or at least makes it easier to manage and scale.<p>Yet, the amount of client capability you need in order to run an accurate performance test still depend on how capable your test target is. Consider a target cluster comprised of 5 nodes. This may take a couple of test clients <em>of the same basic hardware profile</em> in order to adequately load the target system without saturating client resources. However, if those clients are saturating their CPUs, this is not enough.<h3 id=verify-client-overhead>Verify client overhead</h3><p>When running serious tests, it is important that you look at your clients’ system utilization metrics. The key metric to watch for is CPU utilization. If it goes over 50%, you may need more client resources in order to keep your metrics accurate. There are a couple ways to approach this.<h3 id=use-a-larger-test-node>Use a larger test node</h3><p>If you need to scale up your test client capabilities, the simplest method is to just use a larger client node. This may also require you to increase the number of threads, but <code>threads=auto</code> will always size up reasonably to the available cores.<h3 id=add-more-client-nodes>Add more client nodes</h3><p>If you need, you can add more nodes to your test. There are a couple of strategies for doing this effectively.<ol><li>If you want to run the same number of operations overall, you can split them over nodes. Simply change your <code>cycles</code> activity param so that it allocates a share of the cycles to each node. For example, a single-node test which uses <code>cycles=1M</code> can be split into two different ones which use <code>cycles=500K</code> and <code>cycles=500k..1M</code>. If you instead simply set the number to <code>500k</code> for each of them, you would be running the same exact operations twice.<li>If you are gathering metrics on a dashboard, you will want to alias the workload name. If you are using <code>Named Scenarios</code> as most users do, then you can simply copy the workload name to another. This allows you to receive distinct metrics by client. When tagged metrics are implemented, this will no longer be necessary.</ol><p>A good rule of thumb to use is 1 client node for each 3 target nodes in a cluster. This will of-course vary by workload and hardware, but it is a reasonable starting point.<p>It is also important to consider the section on <a href=https://docs.nosqlbench.io/guides/testing/scale/client-sizing/scaling-math.md>Scaling Math</a> when sizing your load bank.</article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>