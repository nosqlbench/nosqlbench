<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Scaling Math | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Understanding the mathematics of scaling distributed systems" name=description><link href=https://docs.nosqlbench.io/guides/testing/scale/scaling-math/ rel=canonical><meta content=https://docs.nosqlbench.io/guides/testing/scale/scaling-math/ property=og:url><meta content=https://docs.nosqlbench.io/guides/testing/scale/scaling-math/ name=twitter:url><meta content="Understanding the mathematics of scaling distributed systems" property=og:description><meta content="Understanding the mathematics of scaling distributed systems" name=twitter:description><meta content="Scaling Math | NoSQLBench Documentation" property=og:title><meta content="Scaling Math | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/guides/testing/scale/scaling-math/>Scaling Math</a></h1><h2 id=scaling-trade-offs>Scaling Trade-Offs</h2><p>In general, there is a triangular trade-off between service time, op rate, and data density, where reads (index traversals or “lookups”) are generally more dependent on working set size than other operations. There is a fundamental three-way trade-off between higher throughput, higher working set, and lower (better) latency. This is true for all modern databases. In general, read patterns always access indexes of some type for a random-access system. The performance of these indexes varies widely based on hardware, software, and data factors. Ideally, index performance tends to Ω(Log₂(n)) for binary search, which approximates the best performance possible, except in special data-dependent cases, where slightly improved performance is possible, but not generally reliable. No matter the underlying hardware, the cardinality of your indexable values <em>will</em> be a factor.<p>This is important to keep in mind, since it makes it very clear that you must test with realistic data – enough data with enough variety and a characteristic distribution. However, you don’t have to do this at the same scale as the system you are characterizing for.<p>The data or index density question can be addressed per unit, meaning per-node, per-core, or whatever the fundamental unit of deployed scale your system architecture offers.<h2 id=test-small-and-extrapolate>Test small and extrapolate</h2><p>It is not necessary nor reasonable to test every system at production scale for the purposes of trusting its operational behavior. The basic principles used to build scalable systems allow for us to build <em>scale</em> models of these systems and verify the character of scaling itself. Nearly all scalable systems amortize work over time and space. There is always a per-unit way of measuring capacity such that the projected capacity is directly proportional to the scale of the system deployment. Identifying how the system capacity relates to the deployment footprint is essential, and depends on the primary scaling mechanisms of the system in question.<p>You want to be able to make reliable statements about the scale of some supposed system deployment from the data you collect in the smaller-scale test, like<ol><li>If I add more data to the existing system, how does this manifest in terms of throughput or latency impact?<li>If I were to add more resources to the system, does it scale up linearly or is there otherwise a reliable estimate which can be used?<li>If a unit of scale is removed (like a node), what happens to the throughput and latency?<li>For a given increase in system resources across the board, how are the throughput and latency affected?</ol><p>To answer these questions, you need to establish some basic formulae and verify them. What this means will depend directly on your system design.<h1 id=test-the-extrapolation>Test the extrapolation</h1><p>Once you have established the formulae to estimate changes in capacity or performance based on changes in system topology, you need change the scale of the system and run your test again to verify that the character of scaling holds. If it does not, then there is an important detail that needs to be discovered and added to the scaling math.<h1 id=trust-your-extrapolation>Trust your extrapolation</h1><p>Once you’ve proven that your scaling math works, it’s time to capture it in context. You need to document the details of the test, including workload, dataset, density, topology, system configuration, and so on. It is only by knowing how similar this system is to another supposed system that you can trust the data for other estimates.<p>A frequent mistake that technologists make when testing systems like this is using the data out of context, against a system where only a couple details have changed. While this might sound reasonable, once you go beyond two or three small changes, our ability to reliably predict systemic changes drops of very quickly. More advanced analysis might help to make this test data more portable, but it is certainly a fools errand to try to intuit too far away from your known configuration.<p>By knowing when a system is congruent to the one you tested, you can known when to trust your scaling math. This is why it is critical that you document the circumstances of what and how you tested, so that in future situations you know if you have meaningfully relevant data.<p>Once you have the ability to extrapolate or interpolate (within reason) how system topology affect the operational behavior of your system, it’s time contextualize your data. If is fair to use the scaling math for other systems which are the same as the one you tested.</article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>