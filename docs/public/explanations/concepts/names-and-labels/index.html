<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Names and Labels | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Understanding NoSQLBench's naming and labeling architecture" name=description><link href=https://docs.nosqlbench.io/explanations/concepts/names-and-labels/ rel=canonical><meta content=https://docs.nosqlbench.io/explanations/concepts/names-and-labels/ property=og:url><meta content=https://docs.nosqlbench.io/explanations/concepts/names-and-labels/ name=twitter:url><meta content="Understanding NoSQLBench's naming and labeling architecture" property=og:description><meta content="Understanding NoSQLBench's naming and labeling architecture" name=twitter:description><meta content="Names and Labels | NoSQLBench Documentation" property=og:title><meta content="Names and Labels | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/explanations/concepts/names-and-labels/>Names and Labels</a></h1><p>Labels are used to identify everything you can configure as a user, and as a result the specific details of where your results come from. Labels are expressed by NoSQLBench as details in metrics, annotations, log lines, error messages, and so on.<h2 id=everything-is-named>Everything is Named</h2><p>Users interact directly with key components of NoSQLBench, such as scenarios, workload templates, op templates, and metrics. Whether configuring a component or analyzing results of a test, it is essential that all components are clearly identified in context. This means that users can configure key elements of a test <em>by name</em>, just as they can look up results in metrics views <em>by name</em>.<p>In cases where users do not provide a name for a component, element, or operation, a name is created for them based on the surrounding structure, so at least error messages, log lines, and other forms of output are specific and relatable to the configuration and workload. Users should not be wondering “Which op template does this error pertain to?”, nor should they be wondering “How do I label the results of this test so that they don’t get mixed up with other results?” The naming and labeling systems are there to provide clear and useful identifiers so this doesn’t happen.<h2 id=everything-is-labeled>Everything is Labeled</h2><p>The runtime context of a single operation in NoSQLBench has layers. An operation is executed for a given cycle, which is run within an activity, which is an independent process within a scenario, which executes with global options. This means that it is not sufficient to only know the name of an operation to isolate it from all others of the same name. You must also know which activity and which scenario it runs within. Imagine you are looking for the results of a specific test run within a dashboard, and there are multiple concurrent results available. The context of the operation is required information to be able to look at and use specific results.<p>Thus, the naming scheme in NoSQLBench is also extended to be used as a labeling system. For any key element that a user can interact with, it will know its label set. Each unique label set uniquely identifies a single and distinct component within the runtime.<p>Naming for all key elements is provided as a set of labels. Strictly speaking, the label set is unordered, however it is maintained in construction order by default to make reading and reasoning about the layers and nesting easier.<h2 id=everything-is-hierarchic>Everything is Hierarchic</h2><p>There are various levels of labeling which are combined for each level of nesting in the runtime. At the outermost layer, there are fewer labels, with more specific labels added as you go deeper.<h2 id=runtime-layers>Runtime Layers</h2><p>A comprehensive view of runtime layers is given below. Those which are called out like <strong>[this]</strong> are provided as standard labels for any metrics, logging, or error conditions as appropriate. They others may be added to specific context views when needed.<ul><li><strong>[session]</strong> - Each runtime session has a unique name by default. A session is a single invocation of NoSQLBench, including global options, scenario or workload selection, etc. <ul><li><strong>[scenario]</strong> - The scenario is the top-level process within the NoSQLBench runtime. It is represented by a scenario script which is either synthesized for the user or provided directly by the user. It’s value is the selected scenario from a named scenario, or just the session name if invoked as an ad-hoc scenario. <ul><li><strong>[activity]</strong> - Within a scenario, zero or more activities will run. An activity is a separate iterative process that runs within a scenario. Activities operate on a set of inputs called cycles, by default an interval of long values. <ul><li><em>thread</em> - An activity has its own thread pool, and each thread operates on cycles from the activity’s cycle source known as an <em>input</em>. <ul><li><em>cycle range</em> - Each thread in an activity iterates over a set of cycles as governed by the <em>stride</em>, which simply aligns the micro-batching size around a logically defined sequence. <ul><li><em>cycle</em> - Each activity thread iterates over the cycles in it’s current cycle range. <ul><li><strong>[op name]</strong> - For a given cycle, a specific deterministic operation is synthesized and executed within the owning thread, and doing any additional logic such as error handling is applied as specified by the user. <ul><li><em>space</em> - Each op can use a named context which remains stateful for the duration of the activity. This is handled by default for most testing scenarios, but can be customized for some powerful testing capabilities when needed.</ul></ul></ul></ul></ul></ul></ul></ul><h2 id=auxiliary-labels>Auxiliary Labels</h2><p>While some of the elements above are labeled as a standard within the runtime, there results of testing may need to be queried, indexed, or aggregated by additional labels which explain the purpose or parameters of a specific test run. These are provided by users in accordance with how that particular layer is normally configured.<h3 id=user-provided-labels>User-Provided Labels</h3><p>Users can add additional labels to be added to the label set for every single element in a session by providing them on the command line.<h3 id=automatic-labels>Automatic Labels</h3><p>Some labels are added for you automatically to describe the usage context of a session, etc.<p><strong>appname</strong><p>A default label of <code>appname</code> is always provided with a value of <code>nosqlbench</code>. This by itself uniquely identifies metrics which were produced by nosqlbench, which is useful in shared metrics settings.<p><strong>workload</strong><p>The name of the workload template which was used in the scenario, if any.<p><strong>usermode</strong><p>This is set to a value like <code>named_scenario</code> or <code>script</code> or <code>adhoc</code> depending on how the scenario was invoked.<p><strong>step</strong><p>The name of the related step from a named scenario if that is how the scenario was invoked.<p><strong>alias</strong><p>This is deprecated. Use <strong>activity</strong> in combination with other labels instead.<h2 id=labels-vs-tags>Labels vs Tags</h2><p>There are two distinct facilities within NoSQLBench for identifying and managing op templates and their related downstream effects.<p><strong>Labels</strong><p>Labels are meant to be nominal for <strong>what something is</strong>, and are applied using a well-defined naming schema as a way to express in detail which consequences are related to which configurations, in detail, and over time.<p><strong>Tags</strong><p>Tags are meant to be useful filters for specifying <strong>which things should be used in a test</strong>, and are applied ad-hoc within workload templates for the purposes of customizing scenarios around specific operations to be included.<p>Each layer is configured and informed by a set of inputs. Each layer adds a specific set of labels, one or more.<h2 id=key-apis>Key APIs</h2><p>The way that labels are supported in NB code is through a labeling API.<h3 id=nblabeledelement>NBLabeledElement</h3><p>NBLabeledElement is a property decorator. It signifies any element which has a set of labels known as NBLabels, accessed with the <code>getLabels()</code> method. In nearly every case, the labels for an element are computed on the fly by combining the parent labels with some named property of the current element. This is why many runtime types require an NBLabeledElement in their constructor as a requirement.<h3 id=nblabels>NBLabels</h3><p>NBLabels provides convenient construction patterns to allow for composing more detailed label sets.<p>For practical usage of the labeling system, see the <a href=../../guides/workload-design/labeling/_index.md>labeling guides</a>.</article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>