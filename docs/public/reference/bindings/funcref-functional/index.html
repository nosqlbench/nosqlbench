<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>flow functions | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Auto-generated reference documentation for flow functions" name=description><link href=https://docs.nosqlbench.io/reference/bindings/funcref-functional/ rel=canonical><meta content=https://docs.nosqlbench.io/reference/bindings/funcref-functional/ property=og:url><meta content=https://docs.nosqlbench.io/reference/bindings/funcref-functional/ name=twitter:url><meta content="Auto-generated reference documentation for flow functions" property=og:description><meta content="Auto-generated reference documentation for flow functions" name=twitter:description><meta content="flow functions | NoSQLBench Documentation" property=og:title><meta content="flow functions | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta content=2025-11-13 property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/reference/bindings/funcref-functional/>flow functions</a></h1><p>These functions help combine other functions into higher-order functions when needed.<h2 id=concatarray>ConcatArray</h2><p>This variant of Concat allows you to apply a string concatenation to a series of string produced by the provided functions. Each position of a delimiter will simply contain all generated values, although usually, you won’t need more than one.<ul><li><code>long -> ConcatArray(String: delimiter, int: size, String: template, Object[]...: functions) -> String</code> <ul><li><em>example:</em> <code>ConcatArray(',',5,'{{}}', NumberNameToString())</code></ul></ul><h2 id=expr>Expr</h2><p>Allow for the use of arbitrary expressions according to the <a href=http://mvel.documentnode.com/ rel=noopener target=_blank>MVEL</a> expression language. Variables that have been set by a Save function are available to be used in this function. The variable name <code>cycle</code> is reserved, and is always equal to the current input value. This is not the same in every case as the current cycle of an operation. It could be different if there are preceding functions which modify the input value.<ul><li><p><code>long -> Expr(String: expr) -> int</code></p><li><p><code>long -> Expr(String: expr) -> long</code></p><li><p><code>long -> Expr(String: expr) -> String</code></p><li><p><code>long -> Expr(String: expr) -> UUID</code></p><li><p><code>int -> Expr(String: expr) -> int</code></p><li><p><code>double -> Expr(String: expr) -> double</code></p><li><p><code>long -> Expr(String: expr) -> Object</code></p></ul><h2 id=hashmix>HashMix</h2><p>Blends two functions with a domain of 0..Long.MAX_VALUE as the input interval, and a double output. The output value is interpolated between the output value of the two according to the mix function. When the mix function yields a value of 0.0, then the mix is turned <em>fully counter-clockwise</em>., or fully on the first provided function. When the value is 1.0, the mix is turned all the clockwise, or fully on the second provided function. If there are only two inner functions provided to HashMix, then it will default to sampling random mixes at a randomized sample point. In other words, the variates provided will be somewhere between the two curves on the unit interval. This is a simple way to sample between two curves by default. The yielded value will be greater than or equal to the lower of the two values at any point, and less than or equal to the greater of either. If a third parameter is provided to control the mix, then the mix can be set directly as a unit interval. (The dial goes from 0.0 to 1.0). Any double or float value here will suffice. You can use this when you want to have a test parameter that slews between two modeled shapes. You can alternately provide any other function which can be coerced to a LongToDouble function as a dynamic mix control. IFF such a function is provided, it must also be responsible for hashing the input value if pseudo-randomness is desired. If a fourth parameter is provided, the sample point can also be controlled. By default, the values on the provided curves will be sampled pseudo-randomly. However, a fourth parameter can override this just like the mix ratio. As well, if you provide a value or function to control the sample point, you are also responsible for any hashing needed to sample across the whole space of possible values. The flexibility of these two parameters provides a substantial amount of flexibility. You can, for example: - sample variates between two curves - sample variates at a selected morphing step between the curves - sample variates between two curves on a subsection of the unit interval - sample variates within a defined band gap of the two curves Blends two functions with a domain of 0..Long.MAX_VALUE as the input interval, and a double output. The output value is interpolated between the output value of the two according to the mix function. When the mix function yields a value of 0.0, then the mix is turned <em>fully counter-clockwise</em>., or fully on the first provided function. When the value is 1.0, the mix is turned all the clockwise, or fully on the second provided function. If there are only two inner functions provided to HashMix, then it will default to sampling random mixes at a randomized sample point. In other words, the variates provided will be somewhere between the two curves on the unit interval. This is a simple way to sample between two curves by default. The yielded value will be greater than or equal to the lower of the two values at any point, and less than or equal to the greater of either. If a third parameter is provided to control the mix, then the mix can be set directly as a unit interval. (The dial goes from 0.0 to 1.0). Any double or float value here will suffice. You can use this when you want to have a test parameter that slews between two modeled shapes. You can alternately provide any other function which can be coerced to a LongToDouble function as a dynamic mix control. IFF such a function is provided, it must also be responsible for hashing the input value if pseudo-randomness is desired. If a fourth parameter is provided, the sample point can also be controlled. By default, the values on the provided curves will be sampled pseudo-randomly. However, a fourth parameter can override this just like the mix ratio. As well, if you provide a value or function to control the sample point, you are also responsible for any hashing needed to sample across the whole space of possible values. The flexibility of these two parameters provides a substantial amount of flexibility. You can, for example: - sample variates between two curves - sample variates at a selected morphing step between the curves - sample variates between two curves on a subsection of the unit interval - sample variates within a defined band gap of the two curves<ul><li><p><code>long -> HashMix(Object: curve1F, Object: curve2F, Object: mixPointF, Object: samplePointF) -> long</code></p> <ul><li><em>example:</em> <code>IntervalHashMix(Func1(),Func2())</code><li><em>yield samples between func1 and func2 values at some random random sample point x</em><li><em>example:</em> <code>IntervalHashMix(Func1(),Func2(),0.25d)</code><li><em>yield samples which are 25% from the sample values for func1 and func2 at some random sample point x</em><li><em>example:</em> <code>IntervalHashMix(Func1(),Func2(),HashRange(0.25d,0.75d)</code><li><em>yield samples between 25% and 75% from func1 to func2 values at some random sample point x</em><li><em>example:</em> <code>IntervalHashMix(Func1(),Func2(),0.0d,ScaledDouble())</code><li><em>access Func1 values as if it were the only one provided. ScaledDouble adds no randomization the input value, but it does map it to the sample domain of 0.0d-0.1d.</em></ul><li><p><code>long -> HashMix(Object: curve1F, Object: curve2F, Object: mixPointF) -> long</code></p><li><p><code>long -> HashMix(Object: curve1F, Object: curve2F) -> long</code></p><li><p><code>long -> HashMix(function.LongToDoubleFunction: f1, function.LongToDoubleFunction: f2) -> long</code></p><li><p><code>long -> HashMix(Object: curve1F, Object: curve2F, Object: mixPointF, Object: samplePointF) -> double</code></p> <ul><li><em>example:</em> <code>HashMix(Func1(),Func2())</code><li><em>yield samples between func1 and func2 values at some random random sample point x</em><li><em>example:</em> <code>HashMix(Func1(),Func2(),0.25d)</code><li><em>yield samples which are 25% from the sample values for func1 and func2 at some random sample point x</em><li><em>example:</em> <code>HashMix(Func1(),Func2(),HashRange(0.25d,0.75d)</code><li><em>yield samples between 25% and 75% from func1 to func2 values at some random sample point x</em><li><em>example:</em> <code>HashMix(Func1(),Func2(),0.0d,ScaledDouble())</code><li><em>access Func1 values as if it were the only one provided. ScaledDouble adds no randomization the input value, but it does map it to the sample domain of 0.0d-0.1d.</em></ul><li><p><code>long -> HashMix(Object: curve1F, Object: curve2F, Object: mixPointF) -> double</code></p><li><p><code>long -> HashMix(Object: curve1F, Object: curve2F) -> double</code></p><li><p><code>long -> HashMix(function.LongToDoubleFunction: f1, function.LongToDoubleFunction: f2) -> double</code></p></ul><h2 id=intflow>IntFlow</h2><p>Combine multiple IntUnaryOperators into a single function.<ul><li><code>int -> IntFlow(function.IntUnaryOperator[]...: ops) -> int</code></ul><h2 id=longflow>LongFlow</h2><p>Combine multiple LongUnaryOperators into a single function.<ul><li><code>long -> LongFlow(function.LongUnaryOperator[]...: ops) -> long</code> <ul><li><em>example:</em> <code>LongFlow(Add(3),Mul(6))</code><li><em>Create an integer operator which adds 3 and multiplies the result by 6</em></ul></ul><h2 id=stringflow>StringFlow</h2><p>Combine multiple String functions together into one function.<ul><li><code>String -> StringFlow(function.Function&LTString,String>[]...: funcs) -> String</code></ul><nav><div><a href=https://docs.nosqlbench.io/reference/bindings/funcref-diagnostics/>‹ diagnostic functions</a></div><div><a href=https://docs.nosqlbench.io/reference/bindings/funcref-nulls/> null functions ›</a></div></nav></article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>