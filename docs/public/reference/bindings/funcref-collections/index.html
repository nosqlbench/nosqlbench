<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>collection functions | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Auto-generated reference documentation for collection functions" name=description><link href=https://docs.nosqlbench.io/reference/bindings/funcref-collections/ rel=canonical><meta content=https://docs.nosqlbench.io/reference/bindings/funcref-collections/ property=og:url><meta content=https://docs.nosqlbench.io/reference/bindings/funcref-collections/ name=twitter:url><meta content="Auto-generated reference documentation for collection functions" property=og:description><meta content="Auto-generated reference documentation for collection functions" name=twitter:description><meta content="collection functions | NoSQLBench Documentation" property=og:title><meta content="collection functions | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta content=2025-11-13 property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/reference/bindings/funcref-collections/>collection functions</a></h1><p>Collection functions allow you to construct Java Lists, Maps or Sets. These functions often take the form of a higher-order function, where the inner function definitions are called to determine the size of the collection, the individual values to be added, etc.<p>For each type of collection, there exists multiple forms which allow you to control how the provided function arguments are used to set the values into the collection.<h2 id=sized-or-pair-wise-functions>Sized or Pair-wise functions</h2><p>Any function in this category with <code>Sized</code> occuring in its name must be initialized with a sizing function as an argument. For example, <code>ListSized(Mod(5),NumberNameToString())</code> will create a list which is sized by the first function – a list between 0 and 4 elements in this case. With an input value of <code>3L</code>, the resulting List will contain 3 elements. With an input of <code>7L</code>, it will contain 2 elements.<p>Alternately, when a function does <em>not</em> contain <code>Sized</code> in its name, the arguments provided are used as pair-wise mapping functions to the elements in the resulting collection.<p>Simply put, a Sized function will always require a sizing function as the first argument.<h2 id=stepped-or-hashed-or-same>Stepped or Hashed or Same</h2><p>Any function in this category which contains <code>Stepped</code> in its name will automatically increment the input value used for each element in the collection. For example <code>ListStepped(NumberNameToString(),NumberNameToString())</code> will always creat a two-element List, but the inputs to the provided functions will be i+0, i+1, where i is the input value to the ListStepped function.<p>Alternately, any function in this category which contains <code>Hashed</code> in its name will automatically hash the input value used for each element. This is useful when you want to create values within a collection that vary significantly with respect of their common seed value. For example, <code>ListHashed(NumberNameToString(),NumberNameToString(),NumberNameToString())</code> will always provide a three element List with values that are not obviously related to each other. For each additional element added to the collection, the previous input is hashed, so there is a relationship, but it will not be obvious nor discernable for most testing purposes.<p>If neither <code>Stepped</code> nor <code>Hashed</code> occurs in the function name, then every element function gets the exact value given to the main function.<h2 id=overview-of-functions>Overview of functions</h2><p>All of the useful collection binding functions follow the same basic patterns above.<h3 id=list-functions>List Functions**</h3><table><thead><tr><th><th>Same Input<th>Stepped Input<th>Hashed Input<tbody><tr><td><strong>Pair-wise</strong><td>ListFunctions(…)<td>ListStepped(…)<td>ListHashed(…)<tr><td><strong>Sized</strong><td>ListSized(…)<td>ListSizedStepped(…)<td>ListSizedHashed(…)</table><p>The name <code>ListFunctions(...)</code> was chosen to avoid clashing with the existing <code>List(...)</code> function.<h3 id=set-functions>Set Functions</h3><p>The values produced by the provided element functions for Sets do not check for duplicate values. This means that you must ensure that your element functions yield distinct values to insert into the collection as it is being built if you want to have a particular cardinality of values in your collection. Overwrites are allowed, although they may not be intended in most cases.<table><thead><tr><th><th>Same Input<th>Stepped Input<th>Hashed Input<tbody><tr><td><strong>Pair-wise</strong><td>SetFunctions(…)<td>SetStepped(…)<td>SetHashed(…)<tr><td><strong>Sized</strong><td>SetSized(…)<td>SetSizedStepped(…)<td>SetSizedHashed(…)</table><p>The name <code>SetFunctions(...)</code> was chosen to avoid clashing with the existing <code>Set(...)</code> function.<h3 id=map-functions>Map Functions</h3><p>The values produced by the provided element functions for Maps do not check for duplicate values. This means that you must ensure that your element functions yield distinct keys to insert into the collection as it is being built if you want to have a particular cardinality of values in your collection. Overwrites are allowed, although they may not be intended in most cases.<table><thead><tr><th><th>Same Input<th>Stepped Input<th>Hashed Input<tbody><tr><td><strong>Pair-wise</strong><td>MapFunctions(…)<td>MapStepped(…)<td>MapHashed(…)<tr><td><strong>Sized</strong><td>MapSized(…)<td>MapSizedStepped(…)<td>MapSizedHashed(…)</table><p>The name <code>MapFunctions(...)</code> was chosen to avoid clashing with the existing <code>Map(...)</code> function.<p>For the key and value functions provided to a Map function, they are taken as even-odd pairs (starting at zero). For sized functions, the last defined key function will be used for elements past the size of the <em>key</em> functions provided. The same is true for the value functions. For example, a call to <code>MapSized(3,f(...),g(...),h(...))</code> will use <code>f(...)</code> and <code>g(...)</code> for the first key and value, but from that point forward will use <code>h(...)</code> for all keys and <code>g(...)</code> for all values.<h2 id=hashedlinetostringlist>HashedLineToStringList</h2><p>Creates a List&LTString> from a list of words in a file.<ul><li><code>long -> HashedLineToStringList(String: filename, int: minSize, int: maxSize) -> List</code></ul><h2 id=hashedlinetostringset>HashedLineToStringSet</h2><p>Return a pseudo-randomly created Set from the values in the specified file.<ul><li><code>long -> HashedLineToStringSet(String: filename, int: minSize, int: maxSize) -> Set&LTString></code> <ul><li><em>example:</em> <code>HashedLineToStringSet('data/variable_words.txt',2,10)</code><li><em>Create a set of words sized between 2 and 10 elements</em></ul></ul><h2 id=hashedlinetostringstringmap>HashedLineToStringStringMap</h2><p>Create a String-String map from the specified file, ranging in size from 0 to the specified maximum.<ul><li><code>long -> HashedLineToStringStringMap(String: paramFile, int: maxSize) -> Map&LTString,String></code></ul><h2 id=hashedrangetolonglist>HashedRangeToLongList</h2><p>Create a list of longs.<ul><li><code>long -> HashedRangeToLongList(int: minVal, int: maxVal, int: minSize, int: maxSize) -> List&LTLong></code></ul><h2 id=join>Join</h2><p>This takes any collection and concatenates the String representation with a specified delimiter.<ul><li><code>Collection&LTT> -> Join(String: delim) -> String</code> <ul><li><em>example:</em> <code>Join(',')</code><li><em>Concatenate the incoming collection with ‘,’</em></ul></ul><h2 id=list>List</h2><p>Create a {@code List} from a long input based on two functions, the first to determine the list size, and the second to populate the list with object values. The input fed to the second function is incremented between elements.<p>To directly create Lists of Strings from the String version of the same mapping functions, simply use {@link StringList} instead.<p>This function is not recommended, given that the other List functions are more clear about how they construct values. This function may be removed in the next major release, but it will be retained as deprecated for now.<ul><li><code>long -> List(Object: sizeFunc, Object: valueFunc) -> List&LTObject></code> <ul><li><em>example:</em> <code>List(HashRange(3,7),Add(15L))</code><li><em>create a list between 3 and 7 elements of Long values</em></ul></ul><h2 id=listfunctions>ListFunctions</h2><p>Create a List from a long input based on a set of provided functions. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions. As neither a ‘Stepped’ nor a ‘Hashed’ function, the input value used by each element function is the same as that provided to the outer function.<ul><li><code>long -> ListFunctions(Object[]...: funcs) -> List&LTObject></code> <ul><li><em>example:</em> <code>ListFunctions(NumberNameToString(),NumberNameToString(),NumberNameToString())</code><li><em>Create a list of object values of each function output. Produces values like [‘one’,‘one’,‘one’]</em></ul></ul><h2 id=listhashed>ListHashed</h2><p>Create a List from a long input based on a set of provided functions. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions. As a ‘Hashed’ function, the input value is hashed again before being used by each element function.<ul><li><code>long -> ListHashed(Object[]...: funcs) -> List&LTObject></code> <ul><li><em>example:</em> <code>ListHashed(ToString(), WeightedStrings('text:1'))</code><li><em>Create a hash list of object values of each function output. ListHashed output [‘2945182322382062539’,‘text’]</em></ul></ul><h2 id=listsized>ListSized</h2><p>Create a List from a long input based on a set of provided functions. As a ‘Sized’ function, the first argument is a function which determines the size of the resulting list. Additional functions provided are used to generate the elements to add to the collection. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed. As neither a ‘Stepped’ nor a ‘Hashed’ function, the input value used by each element function is the same as that provided to the outer function.<ul><li><code>long -> ListSized(Object: sizeFunc, Object[]...: funcs) -> List&LTObject></code> <ul><li><em>example:</em> <code>ListSized(FixedValue(5), NumberNameToString(),NumberNameToString(), WeightedStrings('text:1'))</code><li><em>Create a sized list of object values of each function output. List size function will recursively call the last function tillend of the list size functions</em></ul></ul><h2 id=listsizedhashed>ListSizedHashed</h2><p>Create a List from a long input based on a set of provided functions. As a ‘Sized’ function, the first argument is a function which determines the size of the resulting list. Additional functions provided are used to generate the elements to add to the collection. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed. As a ‘Hashed’ function, the input value is hashed again before being used by each element function.<ul><li><code>long -> ListSizedHashed(Object: sizeFunc, Object[]...: funcs) -> List&LTObject></code> <ul><li><em>example:</em> <code>ListSizedHashed(FixedValue(5),long->ToString(),long->WeightedStrings('text:1'),long->ToString())</code><li><em>Create a sized hash list of object values of each function output. List size function will recursively call the last function tillend of the list size functions</em></ul></ul><h2 id=listsizedstepped>ListSizedStepped</h2><p>Create a List from a long input based on a set of provided functions.<p>As a ‘Sized’ function, the first argument is a function which determines the size of the resulting list. Additional functions provided are used to generate the elements to add to the collection. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed.<p>As a ‘Stepped’ function, the input value is incremented before being used by each element function.<ul><li><code>long -> ListSizedStepped(Object: sizeFunc, Object[]...: funcs) -> List&LTObject></code> <ul><li><em>example:</em> <code>ListSizedStepped(2,NumberNameToString(),NumberNameToString())</code><li><em>Create a list of elements like [‘zero’,‘one’]</em><li><em>example:</em> <code>ListSizedStepped(2,HashRange(1f,10f))</code><li><em>Create a list of elements like [3.8738558, 7.139979]</em></ul></ul><h2 id=liststepped>ListStepped</h2><p>Create a List from a long input based on a set of provided functions. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions. As a ‘Stepped’ function, the input value is incremented before being used by each element function.<ul><li><code>long -> ListStepped(Object[]...: funcs) -> List&LTObject></code> <ul><li><em>example:</em> <code>ListStepped(NumberNameToString(),NumberNameToString())</code><li><em>Create a list of [‘one’,‘two’]</em></ul></ul><h2 id=map>Map</h2><p>Create a {@code Map} from a long input based on three functions, the first to determine the map size, and the second to populate the map with key objects, and the third to populate the map with value objects. The long input fed to the second and third functions is incremented between entries. To directly create Maps with key and value Strings using the same mapping functions, simply use {@link StringMap} instead.<ul><li><p><code>long -> Map(function.LongToIntFunction: sizeFunc, function.LongFunction&LTObject>: keyFunc, function.LongFunction&LTObject>: valueFunc) -> Map&LTObject,Object></code></p> <ul><li><em>example:</em> <code>Map(HashRange(3,7),NumberNameToString(),HashRange(1300,1700))</code><li><em>create a map of size 3-7 entries, with a key of type string and a value of type int (Integer by autoboxing)</em></ul><li><p><code>long -> Map(function.LongFunction&LTObject>[]...: objfuncs) -> Map&LTObject,Object></code></p> <ul><li><em>notes:</em> This version will allow for an odd number of arguments, in which case it will fall back to the other mode where the first argument is a sizing function<li><em>example:</em> <code>Map(NumberNameToString(),HashRange(1300,1700),NumberNameToString(),HashRange(3,7))</code><li><em>create a map of size 2, with a specific function for each key and each value</em></ul></ul><h2 id=mapfunctions>MapFunctions</h2><p>Create a Map from a long input based on a set of provided key and value functions. Any duplicate entries produced by the key functions are elided. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions. Since this is a map, the functions come in pairs, each even numbered function is a key function and each odd numbered function is the corresponding value function. As neither a ‘Stepped’ nor a ‘Hashed’ function, the input value used by each key and value function is the same as that provided to the outer function.<ul><li><code>long -> MapFunctions(Object[]...: funcs) -> Map&LTObject,Object></code> <ul><li><em>example:</em> <code>MapFunctions(NumberNameToString(),NumberNameToString(),ToString(),ToString())</code><li><em>Create a map of object values. Produces values like {‘one’:’one’1:1}.</em></ul></ul><h2 id=maphashed>MapHashed</h2><p>Create a Map from a long input based on a set of provided key and value functions. Any duplicate entries produced by the key functions are elided. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions. Since this is a map, the functions come in pairs, each even numbered function is a key function and each odd numbered function is the corresponding value function. As a ‘Hashed’ function, the input value is hashed again before being used by each key and value function.<ul><li><code>long -> MapHashed(Object[]...: funcs) -> Map&LTObject,Object></code> <ul><li><em>example:</em> <code>MapHashed(NumberNameToString(),NumberNameToString(),ToString(),ToString())</code><li><em>Create a map of object values. Produces values like {‘one’:‘one’,‘4464361019114304900’,‘4464361019114304900’}.</em></ul></ul><h2 id=mapsized>MapSized</h2><p>Create a Map from a long input based on a set of provided key and value functions. Any duplicate entries produced by the key functions are elided. As a ‘Sized’ function, the first argument is a function which determines the size of the resulting map. Additional functions provided are used to generate the elements to add to the collection, as in the pair-wise mode of {@link MapFunctions}. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed. (respectively for key functions as well as value functions) As neither a ‘Stepped’ nor a ‘Hashed’ function, the input value used by each key and value function is the same as that provided to the outer function.<ul><li><p><code>long -> MapSized(Object: sizeFunc, Object[]...: funcs) -> Map&LTObject,Object></code></p> <ul><li><em>example:</em> <code>MapSized(1, NumberNameToString(),NumberNameToString(),ToString(),ToString())</code><li><em>Create a map of object values. Produces values like {‘one’:’one’1:1}.</em></ul><li><p><code>long -> MapSized(int: size, Object[]...: funcs) -> Map&LTObject,Object></code></p></ul><h2 id=mapsizedhashed>MapSizedHashed</h2><p>Create a Map from a long input based on a set of provided key and value functions. Any duplicate entries produced by the key functions are elided. As a ‘Sized’ function, the first argument is a function which determines the size of the resulting map. Additional functions provided are used to generate the elements to add to the collection, as in the pair-wise mode of {@link MapFunctions}. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed. (respectively for key functions as well as value functions) As a ‘Hashed’ function, the input value is hashed again before being used by each key and value function.<ul><li><p><code>long -> MapSizedHashed(Object: sizeFunc, Object[]...: funcs) -> Map&LTObject,Object></code></p> <ul><li><em>example:</em> <code>MapSizedHashed(1, NumberNameToString(),NumberNameToString(),ToString(),ToString())</code><li><em>Create a map of object values. Produces values like {‘one’:’one’1:1}.</em><li><em>example:</em> <code>MapSizedHashed(HashRange(3,5), NumberNameToString(),NumberNameToString())</code><li><em>Create a map of object values. Produces values like {‘one’:’one’1:1}.</em></ul><li><p><code>long -> MapSizedHashed(int: size, Object[]...: funcs) -> Map&LTObject,Object></code></p></ul><h2 id=mapsizedstepped>MapSizedStepped</h2><p>Create a Map from a long input based on a set of provided key and value functions. Any duplicate entries produced by the key functions are elided. As a ‘Sized’ function, the first argument is a function which determines the size of the resulting map. Additional functions provided are used to generate the elements to add to the collection, as in the pair-wise mode of {@link MapFunctions}. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed. (respectively for key functions as well as value functions) As a ‘Stepped’ function, the input value is incremented before being used by each key or value function.<ul><li><p><code>long -> MapSizedStepped(Object: sizeFunc, Object[]...: funcs) -> Map&LTObject,Object></code></p> <ul><li><em>example:</em> <code>MapSizedStepped(1, NumberNameToString(),NumberNameToString())</code><li><em>Create a map of object values. Produces values like {‘one’:’one’1:1}.</em></ul><li><p><code>long -> MapSizedStepped(int: size, Object[]...: funcs) -> Map&LTObject,Object></code></p></ul><h2 id=mapstepped>MapStepped</h2><p>Create a Map from a long input based on a set of provided key and value functions. Any duplicate entries produced by the key functions are elided. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions. Since this is a map, the functions come in pairs, each even numbered function is a key function and each odd numbered function is the corresponding value function. As a ‘Stepped’ function, the input value is incremented before being used by each key or value function.<ul><li><code>long -> MapStepped(Object[]...: funcs) -> Map&LTObject,Object></code> <ul><li><em>example:</em> <code>MapStepped(NumberNameToString(),NumberNameToString(),ToString(),ToString())</code><li><em>Create a map of object values. Produces values like {‘one’:’one’1:1}.</em></ul></ul><h2 id=set>Set</h2><p>Create a {@code Set} from a long input based on two functions, the first to determine the set size, and the second to populate the set with object values. The input fed to the second function is incremented between elements.<p>To create Sets of Strings from the String version of the same mapping functions, simply use {@link StringSet} instead.<ul><li><p><code>long -> Set(function.LongToIntFunction: sizeFunc, function.LongFunction&LTObject>: valueFunc) -> Set&LTObject></code></p> <ul><li><em>example:</em> <code>Set(HashRange(3,7),Add(15L))</code><li><em>create a set between 3 and 7 elements of Long values</em></ul><li><p><code>long -> Set(function.LongToIntFunction: sizeFunc, function.LongUnaryOperator: valueFunc) -> Set&LTObject></code></p><li><p><code>long -> Set(function.LongToIntFunction: sizeFunc, function.LongToIntFunction: valueFunc) -> Set&LTObject></code></p><li><p><code>long -> Set(function.LongFunction&LTObject>: sizeFunc, function.LongFunction&LTObject>: valueFunc) -> Set&LTObject></code></p><li><p><code>long -> Set(function.LongFunction&LTObject>: sizeFunc, function.LongUnaryOperator: valueFunc) -> Set&LTObject></code></p><li><p><code>long -> Set(function.LongFunction&LTObject>: sizeFunc, function.LongToIntFunction: valueFunc) -> Set&LTObject></code></p><li><p><code>long -> Set(function.LongUnaryOperator: sizeFunc, function.LongFunction&LTObject>: valueFunc) -> Set&LTObject></code></p><li><p><code>long -> Set(function.LongUnaryOperator: sizeFunc, function.LongUnaryOperator: valueFunc) -> Set&LTObject></code></p><li><p><code>long -> Set(function.LongUnaryOperator: sizeFunc, function.LongToIntFunction: valueFunc) -> Set&LTObject></code></p></ul><h2 id=setfunctions>SetFunctions</h2><p>Create a Set from a long input based on a set of provided functions. Any duplicate values are elided. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions. As neither a ‘Stepped’ nor a ‘Hashed’ function, the input value used by each element function is the same as that provided to the outer function.<ul><li><code>long -> SetFunctions(Object[]...: funcs) -> Set&LTObject></code> <ul><li><em>example:</em> <code>SetFunctions(NumberNameToString(),NumberNameToString(),NumberNameToString())</code><li><em>Create a list of object values of each function output. Produces values like [‘one’], as each function produces the same value.</em></ul></ul><h2 id=sethashed>SetHashed</h2><p>Create a Set from a long input based on a set of provided functions. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions, assuming no duplicate values. As a ‘Hashed’ function, the input value is hashed again before being used by each element function.<ul><li><code>long -> SetHashed(Object[]...: funcs) -> Set&LTObject></code> <ul><li><em>example:</em> <code>SetHashed(ToString(), WeightedStrings('text:1'))</code><li><em>Create a hash list of object values of each function output, like [‘2945182322382062539’,‘text’]</em></ul></ul><h2 id=setsized>SetSized</h2><p>Create a Set from a long input based on a set of provided functions. As a ‘Sized’ function, the first argument is a function which determines the size of the resulting set. Additional functions provided are used to generate the elements to add to the collection. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed. As neither a ‘Stepped’ nor a ‘Hashed’ function, the input value used by each element function is the same as that provided to the outer function.<ul><li><p><code>long -> SetSized(Object: sizeFunc, Object[]...: funcs) -> Set&LTObject></code></p> <ul><li><em>example:</em> <code>SetSized(FixedValue(5), NumberNameToString(), WeightedStrings('text:1'))</code><li><em>Create a sized set of object values, like [‘one’,‘text’], because ‘text’ is duplicated 4 times</em></ul><li><p><code>long -> SetSized(int: size, Object[]...: funcs) -> Set&LTObject></code></p></ul><h2 id=setsizedhashed>SetSizedHashed</h2><p>Create a Set from a long input based on a set of provided functions. As a ‘Sized’ function, the first argument is a function which determines the size of the resulting set. Additional functions provided are used to generate the elements to add to the collection. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed. As a ‘Hashed’ function, the input value is hashed again before being used by each element function.<ul><li><p><code>long -> SetSizedHashed(Object: sizeFunc, Object[]...: funcs) -> Set&LTObject></code></p> <ul><li><em>example:</em> <code>SetSizedHashed(FixedValue(5),long->ToString(),long->WeightedStrings('text:1'),long->ToString())</code><li><em>Create a sized set of values like [‘2945182322382062539’, ‘text’, ‘37945690212757860’, ‘287864597160630738’, ‘3299224200079606887’]</em></ul><li><p><code>long -> SetSizedHashed(int: size, Object[]...: funcs) -> Set&LTObject></code></p></ul><h2 id=setsizedstepped>SetSizedStepped</h2><p>Create a Set from a long input based on a set of provided functions. As a ‘Sized’ function, the first argument is a function which determines the size of the resulting set. Additional functions provided are used to generate the elements to add to the collection. If the size is larger than the number of provided functions, the last provided function is used repeatedly as needed. As a ‘Stepped’ function, the input value is incremented before being used by each element function.<ul><li><p><code>long -> SetSizedStepped(Object: sizeFunc, Object[]...: funcs) -> Set&LTObject></code></p> <ul><li><em>example:</em> <code>SetSizedStepped(Mod(3),NumberNameToString(),NumberNameToString())</code><li><em>Create a set, like [‘three’,‘four’]</em></ul><li><p><code>long -> SetSizedStepped(int: size, Object[]...: funcs) -> Set&LTObject></code></p></ul><h2 id=setstepped>SetStepped</h2><p>Create a Set from a long input based on a set of provided functions. As a ‘Pair-wise’ function, the size of the resulting collection is determined directly by the number of provided element functions, assuming no duplicate values. As a ‘Stepped’ function, the input value is incremented before being used by each element function.<ul><li><code>long -> SetStepped(Object[]...: funcs) -> Set&LTObject></code> <ul><li><em>example:</em> <code>SetStepped(NumberNameToString(),NumberNameToString())</code><li><em>Create a list of [‘one’,‘two’]</em></ul></ul><h2 id=stringlist>StringList</h2><p>Create a {@code List} from a long value, based on two functions, the first to determine the list size, and the second to populate the list with String values. The input fed to the second function is incremented between elements. Regardless of the object type provided by the second function, {@link Object#toString()} is used to get the value to add to the list.<p>To create Lists of any type of object simply use {@link List} with an specific value mapping function.<ul><li><code>long -> StringList(function.LongToIntFunction: sizeFunc, function.LongFunction&LTObject>: valueFunc) -> List&LTString></code> <ul><li><em>example:</em> <code>StringList(HashRange(3,7),Add(15L))</code><li><em>create a list between 3 and 7 elements of String representations of Long values</em></ul></ul><h2 id=stringmap>StringMap</h2><p>Create a {@code Map} from a long input based on three functions, the first to determine the map size, and the second to populate the map with key objects, and the third to populate the map with value objects. The long input fed to the second and third functions is incremented between entries. Regardless of the object type provided by the second and third functions, {@link Object#toString()} is used to determine the key and value to add to the map. To create Maps of any key and value types, simply use {@link Map} with an specific key and value mapping functions.<ul><li><p><code>long -> StringMap(function.LongToIntFunction: sizeFunc, function.LongFunction&LTObject>: keyFunc, function.LongFunction&LTObject>: valueFunc) -> Map&LTString,String></code></p> <ul><li><em>example:</em> <code>StringMap(HashRange(3,7),NumberNameToString(),HashRange(1300,1700))</code><li><em>create a map of size 3-7 entries, with a key of type string and a value of type int (Integer by autoboxing)</em></ul><li><p><code>long -> StringMap(function.LongFunction&LTObject>[]...: objfuncs) -> Map&LTString,String></code></p> <ul><li><em>example:</em> <code>StringMap(NumberNameToString(),HashRange(1300,1700),NumberNameToString(),HashRange(3,7))</code><li><em>create a map of size 2, with a specific function for each key and each value</em></ul></ul><h2 id=stringset>StringSet</h2><p>Create a {@code Set} from a long based on two functions, the first to determine the set size, and the second to populate the set with String values. The input fed to the second function is incremented between elements. Regardless of the object type provided by the second function, {@link Object#toString()} is used to get the value to add to the list. To create Sets of any type of object simply use {@link Set} with a specific value mapping function.<ul><li><p><code>long -> StringSet(function.LongToIntFunction: sizeFunc, function.LongFunction&LTObject>: valueFunc) -> Set&LTString></code></p> <ul><li><em>example:</em> <code>StringSet(HashRange(3,7),Add(15L))</code><li><em>create a set between 3 and 7 elements of String representations of Long values</em></ul><li><p><code>long -> StringSet(function.LongToIntFunction: sizeFunc, function.LongUnaryOperator: valueFunc) -> Set&LTString></code></p><li><p><code>long -> StringSet(function.LongToIntFunction: sizeFunc, function.LongToIntFunction: valueFunc) -> Set&LTString></code></p><li><p><code>long -> StringSet(function.LongFunction&LT?>: sizeFunc, function.LongFunction&LTObject>: valueFunc) -> Set&LTString></code></p><li><p><code>long -> StringSet(function.LongFunction&LT?>: sizeFunc, function.LongUnaryOperator: valueFunc) -> Set&LTString></code></p><li><p><code>long -> StringSet(function.LongFunction&LT?>: sizeFunc, function.LongToIntFunction: valueFunc) -> Set&LTString></code></p><li><p><code>long -> StringSet(function.LongUnaryOperator: sizeFunc, function.LongFunction&LTObject>: valueFunc) -> Set&LTString></code></p><li><p><code>long -> StringSet(function.LongUnaryOperator: sizeFunc, function.LongUnaryOperator: valueFunc) -> Set&LTString></code></p><li><p><code>long -> StringSet(function.LongUnaryOperator: sizeFunc, function.LongToIntFunction: valueFunc) -> Set&LTString></code></p></ul><nav><div><a href=https://docs.nosqlbench.io/reference/bindings/funcref-state/>‹ state functions</a></div><div><a href=https://docs.nosqlbench.io/reference/bindings/funcref-diagnostics/> diagnostic functions ›</a></div></nav></article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>