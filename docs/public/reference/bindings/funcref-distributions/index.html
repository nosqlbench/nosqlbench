<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>distribution functions | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Auto-generated reference documentation for distribution functions" name=description><link href=https://docs.nosqlbench.io/reference/bindings/funcref-distributions/ rel=canonical><meta content=https://docs.nosqlbench.io/reference/bindings/funcref-distributions/ property=og:url><meta content=https://docs.nosqlbench.io/reference/bindings/funcref-distributions/ name=twitter:url><meta content="Auto-generated reference documentation for distribution functions" property=og:description><meta content="Auto-generated reference documentation for distribution functions" name=twitter:description><meta content="distribution functions | NoSQLBench Documentation" property=og:title><meta content="distribution functions | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta content=2025-11-13 property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/reference/bindings/funcref-distributions/>distribution functions</a></h1><p>All of the distributions that are provided in the Apache Commons Math project are supported here, in multiple forms.<h2 id=continuous-or-discrete>Continuous or Discrete</h2><p>These distributions break down into two main categories:<h3 id=continuous-distributions>Continuous Distributions</h3><p>These are distributions over real numbers like 23.4323, with continuity across the values. Each of the continuous distributions can provide samples that fall on an interval of the real number line. Continuous probability distributions include the <em>Normal</em> distribution, and the <em>Exponential</em> distribution, among many others.<h3 id=discrete-distributions>Discrete Distributions</h3><p>Discrete distributions, also known as <em>integer distributions</em> have only whole-number valued samples. These distributions include the <em>Binomial</em> distribution, the <em>Zipf</em> distribution, and the <em>Poisson</em> distribution, among others.<h2 id=hashed-or-mapped>Hashed or Mapped</h2><h3 id=hashed-samples>hashed samples</h3><p>Generally, you will want to “randomly sample” from a probability distribution. This is handled automatically by the functions below if you do not override the defaults. <strong>The <code>hash</code> mode is the default sampling mode for probability distributions.</strong> This is accomplished by hashing the input before using the resulting value with the sampling curve. This is called the <code>hash</code> sampling mode by VirtData. You can put <code>hash</code> into the modifiers as explained below if you want to document it explicitly.<h3 id=mapped-samples>mapped samples</h3><p>The method used to sample from these distributions depends on a mathematical function called the cumulative probability density function, or more specifically the inverse of it. Having this function computed over some interval allows one to sample the shape of a distribution progressively if desired. In other words, it allows for some <em>percentile-like</em> view of values within a given probability distribution. This mode of using the inverse cumulative density function is known as the <code>map</code> mode in VirtData, as it allows one to map a unit interval variate in a deterministic way to a density sampling curve. To enable this mode, simply pass <code>map</code> as one of the function modifiers for any function in this category.<h2 id=interpolated-or-computed-samples>Interpolated or Computed Samples</h2><p>When sampling from mathematical models of probability densities, performance between different densities can vary drastically. This means that you may end up perturbing the results of your test in an unexpected way simply by changing parameters of your testing distributions. Even worse, some densities have painful corner cases in performance, like ‘Zipf’, which can make tests unbearably slow and flawed as they chew up CPU resources.<p><strong>NOTE:</strong> Functions like ‘Zipf’ can still take a long time to initialize for certain parameters. If you are seeing a workload that seems to hang while initializing, it might be computing complex integrals for large parameters of Zipf. We hope to pre-compute and cache these at a future time to avoid this type of impact. For now, just be aware that some parameters on some density curves can be expensive to compute <em>even during initialization</em>.<h3 id=interpolated-samples>Interpolated Samples</h3><p>For this reason, interpolation is built-in to these sampling functions. <strong>The default mode is <code>interpolate</code>.</strong> This means that the sampling function is pre-computed over 1000 equidistant points in the unit interval (0.0,1.0), and the result is shared among all threads as a look-up-table for interpolation. This makes all statistical sampling functions perform nearly identically at runtime (after initialization, a one time cost). This does have the minor side effect of a little loss in accuracy, but the difference is generally negligible for nearly all performance testing cases.<h4 id=infinite-or-finite>Infinite or Finite</h4><p>For interpolated samples from continuous distributions, you also have the option of including or excluding infinite values which may occur in some distributions. If you want to include them, use <code>infinite</code>, or <code>finite</code> to explicitly avoid them (the default). Specifying ‘infinite’ doesn’t guarantee that you will see +Infinity or -Infinity, only that they are allowed. The Normal distribution often contains -Infinity and +Infinity, for example, due to the function used to estimate its cumulative distribution. These values can often be valuable in finding corner cases which should be treated uniformly according to <a href=https://en.wikipedia.org/wiki/IEEE_754 rel=noopener target=_blank>IEEE 754</a>.<h4 id=clamp-or-noclamp>Clamp or Noclamp</h4><p>For interpolated samples from continuous distributions, you also have the option of clamping the allowed values to the valid range for the integral data type used as input. To clamp the output values to the range (Long.MIN_VALUE,Long.MAX_VALUE) for long->double functions, or to (Integer. MIN_VALUE,Integer.MAX_VALUE) for int-double functions, specify <code>clamp</code>, which is also the default. To explicitly disable this, use <code>noclamp</code>. This is useful when you know the downstream functions will only work with a certain range of values without truncating conversions. When you are using double values natively on the downstream functions, use <code>noclamp</code> to avoid limiting the domain of values in your test data. (In this case, you might also consider <code>infinite</code>).<h3 id=computed-samples>Computed Samples</h3><p>Conversely, <code>compute</code> mode sampling calls the sampling function every time a sample is needed. This affords a little more accuracy, but is generally <em>not</em> preferable to the default interpolated mode. You’ll know if you need computed samples. Otherwise, it’s best to stick with interpolation so that you spend more time testing your target system and less time testing your data generation functions.<h2 id=input-range>Input Range</h2><p>All of these functions take a long as the input value for sampling. This is similar to how the unit interval (0.0,1.0) is used in mathematics and statistics, but more tailored to modern system capabilities. Instead of using the unit interval, we simply use the interval of all positive longs. This provides more compatibility with other functions in VirtData, including hashing functions. Internally, this value is automatically converted to a unit interval variate as needed to work well with the distributions from Apache Math.<h2 id=beta>Beta</h2><p>@see <a href=https://en.wikipedia.org/wiki/Beta_distribution rel=noopener target=_blank>Wikipedia: Beta distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/BetaDistribution.html rel=noopener target=_blank>Commons JavaDoc: BetaDistribution</a><ul><li><p><code>long -> Beta(double: alpha, double: beta, String[]...: mods) -> double</code></p><li><p><code>int -> Beta(double: alpha, double: beta, String[]...: mods) -> double</code></p></ul><h2 id=binomial>Binomial</h2><p>@see <a href=http://en.wikipedia.org/wiki/Binomial_distribution rel=noopener target=_blank>Wikipedia: Binomial distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/BinomialDistribution.html rel=noopener target=_blank>Commons JavaDoc: BinomialDistribution</a><ul><li><p><code>int -> Binomial(int: trials, double: p, String[]...: modslist) -> int</code></p><li><p><code>long -> Binomial(int: trials, double: p, String[]...: modslist) -> long</code></p><li><p><code>int -> Binomial(int: trials, double: p, String[]...: modslist) -> long</code></p><li><p><code>long -> Binomial(int: trials, double: p, String[]...: modslist) -> int</code></p></ul><h2 id=cauchy>Cauchy</h2><p>@see <a href=http://en.wikipedia.org/wiki/Cauchy_distribution rel=noopener target=_blank>Wikipedia: Cauchy_distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/CauchyDistribution.html rel=noopener target=_blank>Commons Javadoc: CauchyDistribution</a><ul><li><p><code>long -> Cauchy(double: median, double: scale, String[]...: mods) -> double</code></p><li><p><code>int -> Cauchy(double: median, double: scale, String[]...: mods) -> double</code></p></ul><h2 id=chisquared>ChiSquared</h2><p>@see <a href=https://en.wikipedia.org/wiki/Chi-squared_distribution rel=noopener target=_blank>Wikipedia: Chi-squared distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ChiSquaredDistribution.html rel=noopener target=_blank>Commons JavaDoc: ChiSquaredDistribution</a><ul><li><p><code>long -> ChiSquared(double: degreesOfFreedom, String[]...: mods) -> double</code></p><li><p><code>int -> ChiSquared(double: degreesOfFreedom, String[]...: mods) -> double</code></p></ul><h2 id=coinfunc>CoinFunc</h2><p>This is a higher-order function which takes an input value, and flips a coin. The first parameter is used as the threshold for choosing a function. If the sample values derived from the input is lower than the threshold value, then the first following function is used, and otherwise the second is used. For example, if the threshold is 0.23, and the input value is hashed and sampled in the unit interval to 0.43, then the second of the two provided functions will be used. The input value does not need to be hashed beforehand, since the user may need to use the full input value before hashing as the input to one or both of the functions. This function will accept either a LongFunction or a {@link Function} or a LongUnaryOperator in either position. If necessary, use {@link function.ToLongFunction} to adapt other function forms to be compatible with these signatures.<ul><li><code>Long -> CoinFunc(double: threshold, Object: first, Object: second) -> Object</code> <ul><li><em>example:</em> <code>CoinFunc(0.15,NumberNameToString(),Combinations('A:1:B:23'))</code><li><em>use the first function 15% of the time</em></ul></ul><h2 id=constantcontinuous>ConstantContinuous</h2><p>Always yields the same value. @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ConstantContinuousDistribution.html rel=noopener target=_blank>Commons JavaDoc: ConstantContinuousDistribution</a><ul><li><p><code>long -> ConstantContinuous(double: value, String[]...: mods) -> double</code></p><li><p><code>int -> ConstantContinuous(double: value, String[]...: mods) -> double</code></p></ul><h2 id=empiricaldistribution>EmpiricalDistribution</h2><p>This distribution is an easy-to use and modify distribution which is simply based on observed or expected frequencies. If you imagine drawing a line across a chart and then being able to use that to model frequencies, that is what this function does. Values must be specified as x,y points, alternating. The x points draw a line segment from left 0.0 to right 1.0 on the unit interval, and the y points plot the magnitude. A LERP table with 1000 fixed points, which provides substantial precision for most systems testing purposes. It is valid to have y values repeated, which is another way of saying that part of the sampled population will have identical values. x coordinates must be monotonically increasing, while y values may be any valid value, even out of order<ul><li><code>long -> EmpiricalDistribution(double[]...: values) -> double</code> <ul><li><em>example:</em> <code>EmpiricalDistribution(0.0d, 0.0d, 1.0d, 1.0d)</code><li><em>Create a uniform distribution, from (x,y)=0,0 to (x,y) = 1,1</em><li><em>example:</em> <code>EmpiricalDistribution(0.0d, 0.0d, 0.333d, 0.1d, 1.0d, 1.0d)</code><li><em>Create a distribution where 1/3 of values range from 0.0 to 0.1 and 2/3 range from 0.1 to 1.0</em></ul></ul><h2 id=enumerated>Enumerated</h2><p>Creates a probability density given the values and optional weights provided, in “value:weight value:weight …” form. The weight can be elided for any value to use the default weight of 1.0d. @see <a href=http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math4/distribution/EnumeratedRealDistribution.html rel=noopener target=_blank>Commons JavaDoc: EnumeratedRealDistribution</a><ul><li><p><code>int -> Enumerated(String: data, String[]...: mods) -> double</code></p> <ul><li><em>example:</em> <code>Enumerated('1 2 3 4 5 6')</code><li><em>a fair six-sided die roll</em><li><em>example:</em> <code>Enumerated('1:2.0 2 3 4 5 6')</code><li><em>an unfair six-sided die roll, where 1 has probability mass 2.0, and everything else has only 1.0</em></ul><li><p><code>long -> Enumerated(String: data, String[]...: mods) -> double</code></p> <ul><li><em>example:</em> <code>Enumerated('1 2 3 4 5 6')</code><li><em>a fair 6-sided die</em><li><em>example:</em> <code>Enumerated('1:2.0 2 3 4 5:0.5 6:0.5')</code><li><em>an unfair fair 6-sided die, where ones are twice as likely, and fives and sixes are half as likely</em></ul></ul><h2 id=enumeratedints>EnumeratedInts</h2><p>Create a sampler based on enumeration of integer values an sample over them using the EnumeratedInts distribution curve provided by Apache Commons Math. This version will roughly produce the distribution, but since it also relies on interpolation by default, non-step values may appear at low frequencies. If this is a desired effect, then this function is suitable. For example: consider this result:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>{@code
</span><span> nb5 run driver=stdout op="{{EnumeratedInts('10:10 20:20 30:30 40:40')}}\n" cycles=10000 | sort -n | uniq -c
</span><span>      1 STDOUT0 (pending,current,complete)=(0,0,10000) 100.00% (last report)
</span><span>      1 9
</span><span>   1036 10
</span><span>      2 11
</span><span>      2 13
</span><span>      1 14
</span><span>      3 15
</span><span>      2 16
</span><span>      1 18
</span><span>      1 19
</span><span>   1937 20
</span><span>      1 21
</span><span>      1 23
</span><span>      1 24
</span><span>      1 25
</span><span>      1 28
</span><span>      1 29
</span><span>   3077 30
</span><span>      1 31
</span><span>      1 33
</span><span>      1 34
</span><span>      2 35
</span><span>      1 37
</span><span>      1 39
</span><span>   3924 40
</span><span>}
</span></code></pre><p>The values here which are not multiples of 10 are not specified, yet the appear. For some testing, this is helpful as a fuzzer, but for more precise step-value sampling, see {@link AliasSampler}<ul><li><p><code>long -> EnumeratedInts(String: data, String[]...: mods) -> int</code></p><li><p><code>int -> EnumeratedInts(String: data, String[]...: mods) -> int</code></p></ul><h2 id=exponential>Exponential</h2><p>@see <a href=https://en.wikipedia.org/wiki/Exponential_distribution rel=noopener target=_blank>Wikipedia: Exponential distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ExponentialDistribution.html rel=noopener target=_blank>Commons JavaDoc: ExponentialDistribution</a><ul><li><p><code>long -> Exponential(double: mean, String[]...: mods) -> double</code></p><li><p><code>int -> Exponential(double: mean, String[]...: mods) -> double</code></p></ul><h2 id=f>F</h2><p>@see <a href=https://en.wikipedia.org/wiki/F-distribution rel=noopener target=_blank>Wikipedia: F-distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/FDistribution.html rel=noopener target=_blank>Commons JavaDoc: FDistribution</a> @see <a href=http://mathworld.wolfram.com/F-Distribution.html rel=noopener target=_blank>Mathworld: F-Distribution</a><ul><li><p><code>int -> F(double: numeratorDegreesOfFreedom, double: denominatorDegreesOfFreedom, String[]...: mods) -> double</code></p><li><p><code>long -> F(double: numeratorDegreesOfFreedom, double: denominatorDegreesOfFreedom, String[]...: mods) -> double</code></p></ul><h2 id=gamma>Gamma</h2><p>@see <a href=https://en.wikipedia.org/wiki/Gamma_distribution rel=noopener target=_blank>Wikipedia: Gamma distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GammaDistribution.html rel=noopener target=_blank>Commons JavaDoc: GammaDistribution</a><ul><li><p><code>long -> Gamma(double: shape, double: scale, String[]...: mods) -> double</code></p><li><p><code>int -> Gamma(double: shape, double: scale, String[]...: mods) -> double</code></p></ul><h2 id=geometric>Geometric</h2><p>@see <a href=http://en.wikipedia.org/wiki/Geometric_distribution rel=noopener target=_blank>Wikipedia: Geometric distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GeometricDistribution.html rel=noopener target=_blank>Commons JavaDoc: GeometricDistribution</a><ul><li><p><code>int -> Geometric(double: p, String[]...: modslist) -> int</code></p><li><p><code>long -> Geometric(double: p, String[]...: modslist) -> long</code></p><li><p><code>int -> Geometric(double: p, String[]...: modslist) -> long</code></p><li><p><code>long -> Geometric(double: p, String[]...: modslist) -> int</code></p></ul><h2 id=gumbel>Gumbel</h2><p>@see <a href=https://en.wikipedia.org/wiki/Gumbel_distribution rel=noopener target=_blank>Wikipedia: Gumbel distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GumbelDistribution.html rel=noopener target=_blank>Commons JavaDoc: GumbelDistribution</a><ul><li><p><code>long -> Gumbel(double: mu, double: beta, String[]...: mods) -> double</code></p><li><p><code>int -> Gumbel(double: mu, double: beta, String[]...: mods) -> double</code></p></ul><h2 id=hypergeometric>Hypergeometric</h2><p>@see <a href=http://en.wikipedia.org/wiki/Hypergeometric_distribution rel=noopener target=_blank>Wikipedia: Hypergeometric distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/HypergeometricDistribution.html rel=noopener target=_blank>Commons JavaDoc: HypergeometricDistribution</a><ul><li><p><code>int -> Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]...: modslist) -> int</code></p><li><p><code>int -> Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]...: modslist) -> long</code></p><li><p><code>long -> Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]...: modslist) -> long</code></p><li><p><code>long -> Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]...: modslist) -> int</code></p></ul><h2 id=intervalhistribution>IntervalHistribution</h2><ul><li><p><code>long -> IntervalHistribution(String: freqs, Object: samplePointFunc) -> long</code></p> <ul><li><em>example:</em> <code>IntervalHistribution('50 25 13 12')</code><li><em>implied frequencies of 0:50 1:25 2:13 3:12</em><li><em>example:</em> <code>IntervalHistribution('234:50 33:25 17:13 3:12')</code><li><em>labeled frequencies; 234,33,17,3 are labels, and 50,25,13,12 are weights</em></ul><li><p><code>long -> IntervalHistribution(String: freqs) -> long</code></p></ul><h2 id=laplace>Laplace</h2><p>@see <a href=https://en.wikipedia.org/wiki/Laplace_distribution rel=noopener target=_blank>Wikipedia: Laplace distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LaplaceDistribution.html rel=noopener target=_blank>Commons JavaDoc: LaplaceDistribution</a><ul><li><p><code>long -> Laplace(double: mu, double: beta, String[]...: mods) -> double</code></p><li><p><code>int -> Laplace(double: mu, double: beta, String[]...: mods) -> double</code></p></ul><h2 id=levy>Levy</h2><p>@see <a href=https://en.wikipedia.org/wiki/L%C3%A9vy_distribution rel=noopener target=_blank>Wikipedia: Lévy distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LevyDistribution.html rel=noopener target=_blank>Commons JavaDoc: LevyDistribution</a><ul><li><p><code>int -> Levy(double: mu, double: c, String[]...: mods) -> double</code></p><li><p><code>long -> Levy(double: mu, double: c, String[]...: mods) -> double</code></p></ul><h2 id=lognormal>LogNormal</h2><p>@see <a href=https://en.wikipedia.org/wiki/Log-normal_distribution rel=noopener target=_blank>Wikipedia: Log-normal distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LogNormalDistribution.html rel=noopener target=_blank>Commons JavaDoc: LogNormalDistribution</a><ul><li><p><code>long -> LogNormal(double: scale, double: shape, String[]...: mods) -> double</code></p><li><p><code>int -> LogNormal(double: scale, double: shape, String[]...: mods) -> double</code></p></ul><h2 id=logistic>Logistic</h2><p>@see <a href=https://en.wikipedia.org/wiki/Logistic_distribution rel=noopener target=_blank>Wikipedia: Logistic distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LogisticDistribution.html rel=noopener target=_blank>Commons JavaDoc: LogisticDistribution</a><ul><li><p><code>int -> Logistic(double: mu, double: scale, String[]...: mods) -> double</code></p><li><p><code>long -> Logistic(double: mu, double: scale, String[]...: mods) -> double</code></p></ul><h2 id=nakagami>Nakagami</h2><p>@see <a href=https://en.wikipedia.org/wiki/Nakagami_distribution rel=noopener target=_blank>Wikipedia: Nakagami distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/NakagamiDistribution.html rel=noopener target=_blank>Commons JavaDoc: NakagamiDistribution</a><ul><li><p><code>long -> Nakagami(double: mu, double: omega, String[]...: mods) -> double</code></p><li><p><code>int -> Nakagami(double: mu, double: omega, String[]...: mods) -> double</code></p></ul><h2 id=normal>Normal</h2><p>@see <a href=https://en.wikipedia.org/wiki/Normal_distribution rel=noopener target=_blank>Wikipedia: Normal distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/NormalDistribution.html rel=noopener target=_blank>Commons JavaDoc: NormalDistribution</a><ul><li><p><code>long -> Normal(double: mean, double: sd, String[]...: mods) -> double</code></p><li><p><code>int -> Normal(double: mean, double: sd, String[]...: mods) -> double</code></p></ul><h2 id=pareto>Pareto</h2><p>@see <a href=https://en.wikipedia.org/wiki/Pareto_distribution rel=noopener target=_blank>Wikipedia: Pareto distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ParetoDistribution.html rel=noopener target=_blank>Commons JavaDoc: ParetoDistribution</a><ul><li><p><code>int -> Pareto(double: scale, double: shape, String[]...: mods) -> double</code></p><li><p><code>long -> Pareto(double: scale, double: shape, String[]...: mods) -> double</code></p></ul><h2 id=pascal>Pascal</h2><p>@see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/PascalDistribution.html rel=noopener target=_blank>Commons JavaDoc: PascalDistribution</a> @see <a href=https://en.wikipedia.org/wiki/Negative_binomial_distribution rel=noopener target=_blank>Wikipedia: Negative binomial distribution</a><ul><li><p><code>long -> Pascal(int: r, double: p, String[]...: modslist) -> int</code></p><li><p><code>int -> Pascal(int: r, double: p, String[]...: modslist) -> long</code></p><li><p><code>long -> Pascal(int: r, double: p, String[]...: modslist) -> long</code></p><li><p><code>int -> Pascal(int: r, double: p, String[]...: modslist) -> int</code></p></ul><h2 id=poisson>Poisson</h2><p>@see <a href=http://en.wikipedia.org/wiki/Poisson_distribution rel=noopener target=_blank>Wikipedia: Poisson distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/PoissonDistribution.html rel=noopener target=_blank>Commons JavaDoc: PoissonDistribution</a><ul><li><p><code>long -> Poisson(double: p, String[]...: modslist) -> long</code></p><li><p><code>int -> Poisson(double: p, String[]...: modslist) -> long</code></p><li><p><code>int -> Poisson(double: p, String[]...: modslist) -> int</code></p><li><p><code>long -> Poisson(double: p, String[]...: modslist) -> int</code></p></ul><h2 id=t>T</h2><p>@see <a href="https://en.wikipedia.org/wiki/Student's_t-distribution" rel=noopener target=_blank>Wikipedia: Student’s t-distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/TDistribution.html rel=noopener target=_blank>Commons JavaDoc: TDistribution</a><ul><li><p><code>int -> T(double: degreesOfFreedom, String[]...: mods) -> double</code></p><li><p><code>long -> T(double: degreesOfFreedom, String[]...: mods) -> double</code></p></ul><h2 id=triangular>Triangular</h2><p>@see <a href=https://en.wikipedia.org/wiki/Triangular_distribution rel=noopener target=_blank>Wikipedia: Triangular distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/TriangularDistribution.html rel=noopener target=_blank>Commons JavaDoc: TriangularDistribution</a><ul><li><p><code>long -> Triangular(double: a, double: c, double: b, String[]...: mods) -> double</code></p><li><p><code>int -> Triangular(double: a, double: c, double: b, String[]...: mods) -> double</code></p></ul><h2 id=uniform>Uniform</h2><p>@see <a href=https://en.wikipedia.org/wiki/Uniform_distribution_(continuous) rel=noopener target=_blank>Wikipedia: Uniform distribution (continuous)</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/UniformContinuousDistribution.html rel=noopener target=_blank>Commons JavaDoc: UniformContinuousDistribution</a><ul><li><p><code>int -> Uniform(double: lower, double: upper, String[]...: mods) -> double</code></p><li><p><code>long -> Uniform(int: lower, int: upper, String[]...: modslist) -> int</code></p><li><p><code>int -> Uniform(int: lower, int: upper, String[]...: modslist) -> int</code></p><li><p><code>int -> Uniform(int: lower, int: upper, String[]...: modslist) -> long</code></p><li><p><code>long -> Uniform(int: lower, int: upper, String[]...: modslist) -> long</code></p><li><p><code>long -> Uniform(double: lower, double: upper, String[]...: mods) -> double</code></p></ul><h2 id=unithistribution>UnitHistribution</h2><p>Empirical Histribution is a portmanteau name to capture the concept of an empirical distribution based on a discrete histogram. This is in contrast to the other similar method [EmpiricalDistribution], which uses a continuous density estimation. Both excel in specific ways. Use this distribution when you have a set of label frequencies which you want to represent accurately.<ul><li><code>double -> UnitHistribution(String: freqs) -> long</code> <ul><li><em>example:</em> <code>UnitHistribution('50 25 13 12')</code><li><em>implied frequencies of 0:50 1:25 2:13 3:12</em><li><em>example:</em> <code>UnitHistribution('234:50 33:25 17:13 3:12')</code><li><em>labeled frequencies; 234,33,17,3 are labels, and 50,25,13,12 are weights</em></ul></ul><h2 id=weibull>Weibull</h2><p>@see <a href=https://en.wikipedia.org/wiki/Weibull_distribution rel=noopener target=_blank>Wikipedia: Weibull distribution</a> @see <a href=http://mathworld.wolfram.com/WeibullDistribution.html rel=noopener target=_blank>Wolfram Mathworld: Weibull Distribution</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/WeibullDistribution.html rel=noopener target=_blank>Commons Javadoc: WeibullDistribution</a><ul><li><p><code>int -> Weibull(double: alpha, double: beta, String[]...: mods) -> double</code></p><li><p><code>long -> Weibull(double: alpha, double: beta, String[]...: mods) -> double</code></p></ul><h2 id=weightedfuncs>WeightedFuncs</h2><p>Allows for easy branching over multiple functions with specific weights.<ul><li><code>long -> WeightedFuncs(Object[]...: weightsAndFuncs) -> Object</code></ul><h2 id=weightedints>WeightedInts</h2><ul><li><code>io.nosqlbench.virtdata.library.basics.core.stathelpers.AliasSamplerDoubleInt -> WeightedInts(String: spec, String[]...: modifiers) -> function.LongToIntFunction</code></ul><h2 id=zipf>Zipf</h2><p>@see <a href="https://en.wikipedia.org/wiki/Zipf's_law" rel=noopener target=_blank>Wikipedia: Zipf’s Law</a> @see <a href=https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ZipfDistribution.html rel=noopener target=_blank>Commons JavaDoc: ZipfDistribution</a><ul><li><p><code>long -> Zipf(int: numberOfElements, double: exponent, String[]...: modslist) -> long</code></p><li><p><code>int -> Zipf(int: numberOfElements, double: exponent, String[]...: modslist) -> long</code></p><li><p><code>long -> Zipf(int: numberOfElements, double: exponent, String[]...: modslist) -> int</code></p><li><p><code>int -> Zipf(int: numberOfElements, double: exponent, String[]...: modslist) -> int</code></p></ul><nav><div><a href=https://docs.nosqlbench.io/reference/bindings/funcref-conversion/>‹ conversion functions</a></div><div><a href=https://docs.nosqlbench.io/reference/bindings/funcref-state/> state functions ›</a></div></nav></article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>