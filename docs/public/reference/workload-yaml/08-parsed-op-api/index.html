<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>ParsedOp API | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Auto-generated reference documentation for ParsedOp API" name=description><link href=https://docs.nosqlbench.io/reference/workload-yaml/08-parsed-op-api/ rel=canonical><meta content=https://docs.nosqlbench.io/reference/workload-yaml/08-parsed-op-api/ property=og:url><meta content=https://docs.nosqlbench.io/reference/workload-yaml/08-parsed-op-api/ name=twitter:url><meta content="Auto-generated reference documentation for ParsedOp API" property=og:description><meta content="Auto-generated reference documentation for ParsedOp API" name=twitter:description><meta content="ParsedOp API | NoSQLBench Documentation" property=og:title><meta content="ParsedOp API | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta content=2025-11-13 property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/reference/workload-yaml/08-parsed-op-api/>ParsedOp API</a></h1><h1 id=parsedop-api>ParsedOp API</h1><p>In the workload template examples, we show statements as being formed from a string value. This is a specific type of statement form, although it is possible to provide structured op templates as well.<p><strong>The ParsedOp API is responsible for converting all valid op template forms into a consistent and unambiguous model.</strong> Thus, the rules for mapping the various forms to the command model must be precise. Those rules are the substance of this specification.<h2 id=op-synthesis>Op Synthesis</h2><p>Executable operations are <em>created</em> on the fly by NoSQLBench via a process called <em>Op Synthesis</em>. This is done incrementally in stages. The following narrative describes this process in logical stages. (The implementation may vary from this, but it explains the effects, nonetheless.)<p>Everything here happens <strong>during</strong> activity initialization, before the activity starts running cycles:<ol><li><em>Template Variable Expansion</em> - If there are template variables, such as <code>TEMPLATE(name,defaultval)</code>, then these are expanded according to their defaults and any overrides provided in the activity params. This is a macro substitution only, so the values are simply interposed into the character stream of the document.<li><em>Jsonnet Evaluation</em> - If the source file was in jsonnet format (the extension was <code>.jsonnet</code>) then it is interpreted by sjsonnet, with all activity parameters available as external variables.<li><em>Structural Normalization</em> - The workload template (yaml, json, or data structure) is loaded into memory and transformed into a standard format. This means taking various list and map forms at every level and converting them to a singular standard form in memory.<li><em>Auto-Naming</em> - All elements which do not already have a name are assigned a simple name like <code>block2</code> or <code>op3</code>.<li><em>Auto-Tagging</em> - All op templates are given standard tag values under reserved tag names: <ul><li><strong>block</strong>: the name of the block containing the op template. For example: <code>block2</code>.<li><strong>name</strong>: the name of the op template, prefixed with the block value and <code>--</code>. For example, <code>block2--op1</code>.</ul><li><em>Property De-normalization</em> - Default values for all the standard op template properties are copied from the doc to the block layer unless the same-named key exists. Then the same method is applied from the doc layer to the op template layer. <strong>At this point, the op templates are effectively an ordered list of data structures, each containing all necessary details for use.</strong><li><em>Tag Filtering</em> - The activity’s <code>tag</code> param is used to filter all the op templates according to their tag map.<li><em>Bind Point and Capture Points</em> - Each op template is now converted into a ParsedOp, which is a swiss-army knife of op template introspection and function generation. It is the direct programmatic API that driver adapters use in subsequent steps. <ul><li>Any string sequences with bind points like <code>this has a {bindpoint}</code> are automatically converted to a long -> string function.<li>Any direct references with no surrounding text like <code>{bindpoint}</code> are automatically converted to direct binding references.<li>Any other string form is cached as a static value.<li>The same process is applied to Lists and Maps, allowing structural templates which read like JSON with bind points in arbitrary places.</ul><li><em>Op Mapping</em> - Using the ParsedOp API, each op template is categorized by the active <code>driver</code> according to that driver’s documented examples and type-matching rules. Once the op mapper determines what op type a user intended, it uses this information and the associated op fields to create an <em>Op Dispenser</em>.<li><em>Op Sequencing</em> - The op dispensers are kept as an internal sequence, and installed into a <a href=https://en.wikipedia.org/wiki/Lookup_table rel=noopener target=_blank>LUT</a> according to their ratios and the specified (or default) sequencer. By default, round-robin with bucket exhaustion is used. The ratios specified are used directly in the LUT.</ol><p>When this is complete, you are left with an efficient lookup table which indexes into a set of OpDispensers. The length of this lookup table is called the <em>sequence length</em>, and that value is used, by default, to set the <em>stride</em> for the activity. This stride determines the size of per-thread cycle batching, effectively turning each sequence into a thread-safe set of operations which are serialized, and thus suitable for testing linearized operations with suitable dependency and error-handling mechanisms. (But wait, there’s more!)<h2 id=special-cases>Special Cases</h2><p>Drivers are assigned to op templates individually, meaning you can specify the driver within an op template, not even assigning a default for the activity. Further, certain drivers are able to fill in missing details for op templates, like the <code>stdout</code> driver which only requires bindings.<p>This means that there are distinct cases for configuration which are valid, and these are checked at initialization time:<ul><li>A <code>driver</code> must be selected for each op template either directly or via activity params.<li>If the whole workload template provided does not include actual op templates <strong>AND</strong> a default driver is provided which can create synthetic op templates, it is given the raw workload template, incomplete as it is, and asked to provide op templates which have all normalization, naming, etc. already done. This is injected before the tag-filtering phase.<li>In any case that an actual non-zero list of op templates is provided and tag filtering removes them all, an error is thrown.<li>If, after tag filtering no op template are in the active list, an error is thrown.</ul><h1 id=the-parsedop>The ParsedOp</h1><p>The components of a fully-parsed op template (AKA a ParsedOp) are:<h2 id=name>name</h2><p>Each ParsedOp knows its name, which is simply the op template name that it was made from. This is useful for diagnostics, logging, and metrics.<h2 id=description>description</h2><p>Every named element of a workload may be given a description.<h2 id=tags>tags</h2><p>Every op template has tags, even if they are auto-assigned from the block and op template names. If you assign explicit tags to an op template, the standard tags are still provided. Thus, it is an error to directly provide a tag named <code>block</code> or <code>name</code>.<h2 id=bindings>bindings</h2><p>Although bindings are usually defined as workload template level property, they can also be provided directly as an op field property.<h2 id=op-fields>op fields</h2><p>The <strong>op</strong> property of an op template or ParsedOp is the root of the op fields. This is a map of specific fields specified by the user.<h3 id=static-op-fields>static op fields</h3><p>Some op fields are simply static values. Since these values are not generated per cycle, they are kept separate as reference data. Knowing which fields are static and which are not makes it possible for developers to optimize op synthesis.<h3 id=dynamic-op-fields>dynamic op fields</h3><p>Other fields may be specified as recipes, with the actual value to be filled-in once the cycle value is known. All such fields are known as <em>dynamic op fields</em>, and are provided to the op dispenser as a long function, where the input is always the cycle value and the output is a type-specific value as determined by the associated binding recipe.<h3 id=bind-points>bind points</h3><p>This is how dynamic values are indicated. Each bind point in an op template results in some type of procedural generation binding. These can be references to named bindings elsewhere in the workload template, or they can be inline.<h3 id=capture-points>capture points</h3><p>Names of result values to save, and the variable names they are to be saved as. The names represent the name as it would be found in the native driver’s API, such as the name <code>userid</code> in <code>select userid from ...</code>. In string form statements, users can specify that the userid should be saved as the thread-local variable named <em>userid</em> simply by tagging it like <code>select [userid] from ...</code>. They can also specify that this value should be captured under a different name with a variation like <code>select [userid as user_id] from ...</code>. This is the standard variable capture syntax for any string-based statement form.<h3 id=params>params</h3><p>A backwards-compatible feature called op params is still available. This is another root property within an op template which can be used to accessorize op fields. By default, any op field which is not explicitly rooted under the <code>op</code> property are put there anyway. This is also true when there is an explicitly <code>params</code> property. However if the op property is provided, then all non-reserved fields are given to the params property instead. If both the <code>op</code> and the <code>param</code> op properties are specified, then no non-reserved op fields are allowed outside of these root values. Thus it is possible to still support params, but it is <strong>highly</strong> recommended that new driver developers avoid using this field, and instead allow all fields to be automatically anchored under the <code>op</code> property. This keeps configs terse and simple going forward.<p>Params may not be dynamic.<h1 id=mapping-rules>Mapping Rules</h1><p>A ParsedOp does not necessarily describe a specific low-level operation to be performed by a native driver. It <em>should</em> do so, but it is up to the user to provide a valid op template according to the documented rules of op construction for that driver type. These rules should be clearly documented by the driver developer as examples in markdown that is required for every driver. With this documentation, users can use <code>nb5 help &amplt;driver&ampgt;</code> to see exactly how to create op templates for a given driver.<h2 id=string-form>String Form</h2><p>Basic operations are made from a statement in some type of query language:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span style=color:#bf616a>ops</span><span>:
</span><span>  - </span><span style=color:#bf616a>stringform</span><span>: </span><span style=color:#a3be8c>select [userid] from db.users where user='{username}';
</span><span>    </span><span style=color:#bf616a>bindings</span><span>:
</span><span>      </span><span style=color:#bf616a>username</span><span>: </span><span style=color:#a3be8c>NumberNameToString()
</span></code></pre><h1 id=reserved-op-fields>Reserved op fields</h1><p>The property names <code>ratio</code>, <code>driver</code>, <code>space</code>, are considered reserved by the NoSQLBench runtime. These are extracted and handled specially by the core runtime.<h1 id=base-opdispenser-fields>Base OpDispenser fields</h1><p>The BaseOpDispenser, which <s>is</s> will be required as the base implementation of any op dispenser going forward, provides cross-cutting functionality. These include <code>start-timers</code>, <code>stop-timers</code>, <code>instrument</code>, and likely will include more as future cross-driver functionality is added. These fields will be considered reserved property names.<h1 id=optimization>Optimization</h1><p>It should be noted that the op mapping process, where user intentions are mapped from op templates to op dispensers is not something that needs to be done quickly. This occurs at <em>initialization</em> time. Instead, it is more important to focus on user experience factors, such as flexibility, obviousness, robustness, correctness, and so on. Thus, priority of design factors in this part of NB is placed more on clear and purposeful abstractions and less on optimizing for speed. The clarity and detail which is conveyed by this layer to the driver developer will then enable them to focus on building fast and correct op dispensers. These dispensers are also constructed before the workload starts running, but are used at high speed while the workload is running.<p>In essence:<ul><li>Any initialization code which happens before or in the OpDispenser constructor should not be concerned with careful performance optimization.<li>Any code which occurs within the OpDispenser#apply method should be as lightweight as is reasonable.</ul><nav><div><a href=https://docs.nosqlbench.io/reference/workload-yaml/07-template-variables/>‹ Template Variables</a></div><div><a href=https://docs.nosqlbench.io/reference/workload-yaml/01-spectest-formatting/> SpecTest Formatting ›</a></div></nav></article></main><footer><div class=c><nav class=tpad><div></div></nav><p>© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>