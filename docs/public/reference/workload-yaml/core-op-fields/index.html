<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Core Op Fields | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Universal op template fields available in all workload templates" name=description><link href=https://docs.nosqlbench.io/reference/workload-yaml/core-op-fields/ rel=canonical><meta content=https://docs.nosqlbench.io/reference/workload-yaml/core-op-fields/ property=og:url><meta content=https://docs.nosqlbench.io/reference/workload-yaml/core-op-fields/ name=twitter:url><meta content="Universal op template fields available in all workload templates" property=og:description><meta content="Universal op template fields available in all workload templates" name=twitter:description><meta content="Core Op Fields | NoSQLBench Documentation" property=og:title><meta content="Core Op Fields | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/reference/workload-yaml/core-op-fields/>Core Op Fields</a></h1><p>Some op template fields are reserved by nb5. These are provided by the runtime, not any particular driver, and can be used in any op template.<p>üëâ op fields can be defined at any level of a workload template with a <code>param</code> property. Op templates which do not have this op field by name will automatically inherit it.<h1 id=general>General</h1><h2 id=driver><em>driver</em></h2><ul><li><em>default</em>: unset<li><em>required</em>: yes, by op template or by activity params<li><em>dynamic</em>: no</ul><p>Each op template in an activity can use a specific driver. If this op field is not provided in the op template, then it is set by default from the activity params. If neither is set, an error is thrown.<p>Since each op template can have a unique driver, and each activity can have multiple op templates, each activity will have multiple drivers active while it is running. These drivers are instanced and shared between op templates which specify the same driver by name.<p>During activity initialization, all the drivers which are loaded by active op templates (those not filtered out) are consulted for valid activity params. Only params which are valid for at least one active driver will be allowed to be set on the activity. This includes <a href=../cli/core-activity-params.md>core activity params</a>.<h2 id=space><em>space</em></h2><ul><li><em>default</em>: ‚Äúdefault‚Äù<li><em>required</em>: yes, but set by default<li><em>dynamic</em>: yes</ul><p>The space is a named cache of driver state. For each driver, a cache of driver-specific ‚Äúdriver space‚Äù objects is kept. If the value is not set in the op template, then the effect is the same as all op templates sharing a single instance of that driver. However, if the users sets the <code>space</code> op field to a binding, then the driver will be virtualized over the names provided, allowing for a given driver to be effectively multi-instanced within the activity.<p>üëâ <strong>Be careful with this op field!</strong> The way it works allows for quite advanced testing scenarios to be built with <em>very minimal</em> effort, compared to nearly all other approaches. However, if you set this op field to a binding function which produces a high cardinality values, you will be asking your client to create many instances of a native driver. This is not likely to end well for at least the client, and in some cases the server. This does present interesting stress testing scenarios, however!<p>When an activity is shutting down, it will automatically close out any driver spaces according to their own built-in shutdown logic, but not until the activity is complete. At present, there is no space cache expiry mechanism, but this can be added if someone needs it.<h2 id=ratio><em>ratio</em></h2><p>An op field called <em>ratio</em> can be specified on an op template to set the number of times this op will occur in the op sequence.<p>When an activity is initialized, all the active statements are combined into a sequence based on their relative ratios. By default, all op templates are initialized with a ratio of 1 if none is specified by the user.<p>For example, consider the op templates below:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span>
</span><span style=color:#bf616a>ops</span><span>:
</span><span>  </span><span style=color:#bf616a>s1</span><span>:
</span><span>    </span><span style=color:#bf616a>op</span><span>: "</span><span style=color:#a3be8c>select foo,bar from baz where ...</span><span>"
</span><span>    </span><span style=color:#bf616a>ratio</span><span>: </span><span style=color:#d08770>1
</span><span>  </span><span style=color:#bf616a>s2</span><span>:
</span><span>    </span><span style=color:#bf616a>op</span><span>: "</span><span style=color:#a3be8c>select bar,baz from foo where ...</span><span>"
</span><span>    </span><span style=color:#bf616a>ratio</span><span>: </span><span style=color:#d08770>2
</span><span>  </span><span style=color:#bf616a>s3</span><span>:
</span><span>    </span><span style=color:#bf616a>op</span><span>: "</span><span style=color:#a3be8c>select baz,foo from bar where ...</span><span>"
</span><span>    </span><span style=color:#bf616a>ratio</span><span>: </span><span style=color:#d08770>3
</span></code></pre><p>If all ops are activated (there is no tag filtering), then the activity will be initialized with a sequence length of 6. In this case, the relative ratio of op ‚Äús3‚Äù will be 50% overall. If you filtered out the first op, then the sequence would be 5 operations long. In this case, the relative ratio of op ‚Äús3‚Äù would be 60% overall. It is important to remember that op ratios are always relative to the total sum of the active ops‚Äô ratios.<p>This op field works closely with the core activity parameter <a href=../cli/core-activity-params.md#seq>seq</a><h1 id=instrumentation>Instrumentation</h1><h2 id=labels>labels</h2><p>If you add a labels property to an op, then these labels are appended to the labels already provided wherever the op is represented in metrics or annotations.<h2 id=instrument>instrument</h2><p>By setting this to true, each named op template will be instrumented with a set of metrics, with the metric name derived from its op name.<p>For example, with the following workload template:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span style=color:#bf616a>ops</span><span>:
</span><span> </span><span style=color:#bf616a>op1</span><span>:
</span><span>   </span><span style=color:#bf616a>op</span><span>: "</span><span style=color:#a3be8c>example stmt1</span><span>"
</span><span>   </span><span style=color:#bf616a>instrument</span><span>: </span><span style=color:#d08770>true
</span><span> </span><span style=color:#bf616a>op2</span><span>:
</span><span>   </span><span style=color:#bf616a>op</span><span>: "</span><span style=color:#a3be8c>example stmt2</span><span>"
</span><span>   </span><span style=color:#bf616a>instrument</span><span>: </span><span style=color:#d08770>true
</span></code></pre><p>With instrument <em>enabled</em> for each of these ops, six additional metrics will be created: four <a href=https://metrics.dropwizard.io/4.2.0/manual/core.html#timers rel=noopener target=_blank>timers</a> named op1-success, op1-error, op2-success, and op2-error, and two <a href=https://metrics.dropwizard.io/4.2.0/manual/core.html#man-core-histograms rel=noopener target=_blank>histograms</a> named op1-result-size and op2-result size.<p>This is very useful for understanding performance dynamics of individual operations. However, be careful when enabling this for a large number of metrics (by setting it as a doc or block level param), especially when you are running with more than 3 significant digits of HDR histogram precision.<h2 id=start-timers>start-timers</h2><h2 id=stop-timers>stop-timers</h2><p>This op fields allow for a timer or set of timers to be started immediately before an operation is started and stopped immediately after another (or the same!) operation is completed. This allows you to instrument your access patterns with arbitrary timers across any number of operations.<p>These timers are started and stopped unconditionally, which means failed operations will be included. Be sure to correlate your metrics so you know what you are truly measuring.<p>For example:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span style=color:#bf616a>ops</span><span>:
</span><span>  </span><span style=color:#bf616a>op1</span><span>:
</span><span>    </span><span style=color:#bf616a>op</span><span>: "</span><span style=color:#a3be8c>example stmt1</span><span>"
</span><span>    </span><span style=color:#bf616a>start-timers</span><span>: </span><span style=color:#a3be8c>stanza1, stanza2
</span><span>  </span><span style=color:#bf616a>op2</span><span>:
</span><span>    </span><span style=color:#bf616a>op</span><span>: "</span><span style=color:#a3be8c>example stmt2</span><span>"
</span><span>    </span><span style=color:#bf616a>stop-timers</span><span>: </span><span style=color:#a3be8c>stanza1
</span><span>  </span><span style=color:#bf616a>op3</span><span>:
</span><span>    </span><span style=color:#bf616a>op</span><span>: "</span><span style=color:#a3be8c>example stmt</span><span>"
</span><span>    </span><span style=color:#bf616a>stop-timers</span><span>: </span><span style=color:#a3be8c>stanza2
</span></code></pre><p>In this case, before op1 is executed, a timer is started for stanza1 and stanza2. After op2 has been executed, successful or not, the timer for stanza1 will be stopped. After op3 has been executed, successful or not, the timer named stanza2 will be stopped.<p>These are treated just like any other timers, with a single named instance per activity, thus the measurements are an aggregate over all threads.<p>üëâ The instancing of these named timers is per-thread! There is no way to cross the streams, so measurements are coherent within serialized operations which represent real access patterns in a given application thread.<h1 id=result-verification>Result Verification</h1><p>You can now verify results of operations using property-based assertions or result equality. These methods use a compiled script which has access to binding variables in the same way that op templates use them, as bind points like <code>... {mybinding} ...</code>. This means that you can write script for verification logic naturally. The verification script is parsed and compiled ahead of time, with full awareness of the bindings which need to be generated before per-cycle evaluation.<p>The verifier is implemented in groovy 4, and is thus compatible with typical Java forms. It also allows for some terse and simplified views for assertion-based testing. Consult the <a href=https://docs.groovy-lang.org/latest/html/documentation/ rel=noopener target=_blank>Groovy Language Documentation</a> or the <a href=https://docs.groovy-lang.org/latest/html/api/ rel=noopener target=_blank>Groovy API docs</a> for more details on the language.<h3 id=verifier-variables>verifier variables</h3><p>Within the scripting environment of the verifier, you can access some pre-defined variables:<ul><li>result - The result of the last operation. This value is provided optionally by different drivers, so if you are using a verifier, ensure that the driver adapter you are using is compatible<li>cycle - The cycle number associated with the op.<li>_parsed_op - The op template in full-parsed form. This can be used for things like naming or labeling data for metrics, or to make some verifier logic conditional on other fields.<li><em>bindings</em> - any binding variables which are defined for your op template can be used. You reference these just as in op templates, like <code>{mybindingvalue}</code>. These are computed and injected per-cycle.</ul><h2 id=verifier>verifier</h2><p>Using the result variable, you can make your assertion logic read like what it does. For example, if you want to verify that the result of an operation is equal to the string ‚Äúthis worked 42!‚Äù, you can specify something like this:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span style=color:#bf616a>ops</span><span>:
</span><span>  </span><span style=color:#bf616a>op1</span><span>:
</span><span>     </span><span style=color:#bf616a>stmt</span><span>: "</span><span style=color:#a3be8c>this worked 42!</span><span style=color:#96b5b4>\n</span><span>"
</span><span>     </span><span style=color:#bf616a>verifier</span><span>: </span><span style=color:#b48ead>|
</span><span style=color:#a3be8c>      result.equals("this worked 42!\n");
</span></code></pre><p>The verifier allows you to use bindings in exactly the same format as your string-based op templates:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span style=color:#bf616a>ops</span><span>:
</span><span>  </span><span style=color:#bf616a>op1</span><span>:
</span><span>    </span><span style=color:#bf616a>stmt</span><span>: "</span><span style=color:#a3be8c>this worked {numname}!</span><span style=color:#96b5b4>\n</span><span>"
</span><span>    </span><span style=color:#bf616a>verifier</span><span>: </span><span style=color:#b48ead>|
</span><span style=color:#a3be8c>      result.equals("this worked ${numname}!\n");
</span><span>    </span><span style=color:#bf616a>bindings</span><span>:
</span><span>     </span><span style=color:#bf616a>numname</span><span>: </span><span style=color:#a3be8c>NumberNameToString();
</span></code></pre><p>This example doesn‚Äôt do much like a real test would, since it is simply asserting that the result looks the way we know it should. However, this mechanism can be used in any scenario where you know a property or feature of a result that you can check for to verify correctness.<p>The verifier can be specified as a string, list, or map structure. In each case, the form is interpreted as a sequence of named verifiers. in the string or list forms, names are created for you. These names may be used in logging or other views needed to verify or troubleshoot the actual logic of your verifier script.<p>When multiple verifiers are supplied, they are executed each in turn. This means that errors will present distinctly when verifiers are separated for clarity.<p>All verifier execution contexts share the same compiled script for a given verifier code body, but each thread has its own instanced variable state, including results. However, the variables which were present after any verifier-init code are injected into the initial context for each instance.<h2 id=expected-result>expected-result</h2><p>If you want to test with a more concise and declarative form, and your result content isn‚Äôt complex, you can use the <code>expected-result</code> op field instead. This form allows you to prototype an object in declarative or literal form which can then be checked against a result using Java equals semantics. For example, to verify the same result as shown with the verifier above, but in a simpler form, you could do this:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span style=color:#bf616a>ops</span><span>:
</span><span>  </span><span style=color:#bf616a>op1</span><span>:
</span><span>    </span><span style=color:#bf616a>stmt</span><span>: "</span><span style=color:#a3be8c>this worked {numname}!</span><span style=color:#96b5b4>\n</span><span>"
</span><span>    </span><span style=color:#bf616a>expected-result</span><span>: "</span><span style=color:#a3be8c>this worked </span><span>"</span><span style=color:#a3be8c>+{numname}+"!\n"
</span><span>    </span><span style=color:#bf616a>bindings</span><span>:
</span><span>     </span><span style=color:#bf616a>numname</span><span>: </span><span style=color:#a3be8c>NumberNameToString();
</span></code></pre><p>Since the expected-result value is rendered by active code, you must treat it as code where the bind points are simply injected variables. This form can also use container types and inline or literal forms.<h2 id=verifier-imports>verifier-imports</h2><p>For the verifier capabilities explained above, you may need to import symbols from packages in your runtime. This allows you to do so. These imports will apply equally to any per-cycle verification logic for the given op template, and only need to be specified once (per op template).<h2 id=verifier-init>verifier-init</h2><p>Sometimes you want to initialize your verifier logic once before you invoke it every cycle. Any verifier code provided in <em>verifier-init</em> fields is run exactly this way. The variable bindings which are created here are persisted and injected into every other verifier as such. This allows you to create instrumentation, for example.<nav><div></div><div><a href=https://docs.nosqlbench.io/reference/workload-yaml/07-template-variables/> Template Variables ‚Ä∫</a></div></nav></article></main><footer><div class=c><nav class=tpad><div></div></nav><p>¬© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>