<!doctype html><html lang=en><head><script integrity=sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1 src=https://docs.nosqlbench.io/js/theme.min.js></script><link href="https://docs.nosqlbench.io/abridge.css?h=17d1d14ae374495df55a" rel=stylesheet><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=https://docs.nosqlbench.io name=base><meta content=True name=HandheldFriendly><meta content=yes name=mobile-web-app-capable><meta content=yes name=apple-mobile-web-app-capable><meta content=default name=apple-mobile-web-app-status-bar-style><link href=https://docs.nosqlbench.io/favicon.svg rel=icon type=image/svg+xml><link title="NoSQLBench Documentation Atom Feed" href=https://docs.nosqlbench.io/atom.xml rel=alternate type=application/atom+xml><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>Core Activity Parameters | NoSQLBench Documentation</title><meta content="NoSQLBench Team" name=author><meta content="NoSQLBench Documentation" name=copyright><meta content="Universal activity parameters available with all drivers" name=description><link href=https://docs.nosqlbench.io/reference/cli/core-activity-params/ rel=canonical><meta content=https://docs.nosqlbench.io/reference/cli/core-activity-params/ property=og:url><meta content=https://docs.nosqlbench.io/reference/cli/core-activity-params/ name=twitter:url><meta content="Universal activity parameters available with all drivers" property=og:description><meta content="Universal activity parameters available with all drivers" name=twitter:description><meta content="Core Activity Parameters | NoSQLBench Documentation" property=og:title><meta content="Core Activity Parameters | NoSQLBench Documentation" name=twitter:title><meta content=summary name=twitter:card><meta content="NoSQLBench Documentation" property=og:site_name><meta content=en_US property=og:locale><meta content=website property=og:type><meta property=og:updated_time><script src="https://docs.nosqlbench.io/js/theme_button.js?h=12a31e87fcbe7a55e953" defer integrity=sha384-UBxLGgFVZtEgNzOU3WqKoFT1oILftGjShFO4WIs1dO/jK7SNyz7BMYCYt5PffTxe></script><script src="https://docs.nosqlbench.io/js/email.js?h=ee3dd742e11c5014fdef" defer integrity=sha384-y0LUfjslyVLYZvCOyhELpvKivlXAq27Vnbed54glXoe/pZSYS/Pfqghp/sQt1xcV></script><script src="https://docs.nosqlbench.io/js/codecopy.js?h=0a54f99e682443925d3a" defer integrity=sha384-qssVvPpQgISh4PFkSBGTgXEMzuFO8Hat5m1MsdkpannoByWSTpLfBe4iEVl3+RiP></script><script src="https://docs.nosqlbench.io/js/elasticlunr.min.js?h=4f648b9e42abdef9c436" defer integrity=sha384-Q8viz7rndi8MSNDtItDgVWNSrCumjepopRMlz2nElkWPRXDQAcfiZGJbrCJVXdtw></script><script src="https://docs.nosqlbench.io/search_index.en.js?h=e2df0fd710d0c807a7aa" defer integrity=sha384-nyOftseEtxo2Pc23RFR1hxsCZHtUr0xOCP7JVJ8oGIs+cnDq6GZkzCq2hWZ2cJIh></script><script src="https://docs.nosqlbench.io/js/searchjava.js?h=36b818b07e8b2b318967" defer integrity=sha384-i6K7Uy98ZLnOwn6no8sDUTeBitDmiLHOKxkcJYbjgu6vQ3hdyMQPzmeuX04BRs8J></script><noscript><link href=https://docs.nosqlbench.io/nojs.css rel=stylesheet></noscript><body><header><nav><div><big><a title="NoSQLBench Documentation" href=https://docs.nosqlbench.io></a></big></div><div><div><ul><li><a href=https://docs.nosqlbench.io/tutorials/> Tutorials </a><li><a href=https://docs.nosqlbench.io/guides/> Guides </a><li><a href=https://docs.nosqlbench.io/reference/> Reference </a><li><a href=https://docs.nosqlbench.io/explanations/> Explanations </a><li><a href=https://docs.nosqlbench.io/development/> Development </a><li><a href=https://github.com/nosqlbench/nosqlbench target=_blank> GitHub </a><li><i class="js svgs adjust" id=mode type=reset></i></ul></div><div><div><form autocomplete=off class=js id=searchbox name=goSearch><div class=searchd><input id=searchinput placeholder=Search title=Search><button class="svgs svgm search" title=Search></button></div><div class=results><div id=suggestions></div></div></form></div></div></div></nav></header><main><article><h1><a href=https://docs.nosqlbench.io/reference/cli/core-activity-params/>Core Activity Parameters</a></h1><p>Activity parameters are passed as named arguments for an activity, either on the command line or from a scenario script. On the command line, these take the form of<pre style=color:#c0c5ce;background-color:#2b303b><code><span>... &LTparam>=&LTvalue> ...
</span></code></pre><p>Some activity parameters are universal in that they can be used with any driver type. These parameters are called <em>core</em> activity params. Only core activity parameters are documented here. When starting out, you want to familiarize yourself with these parameters.<p>üëâ To see what activity parameters are valid for a given driver, see the documentation for that driver with <code>nb5 help &LTdriver></code>. Each driver comes with documentation that describes what how to configure it with additional driver params as well as what op template forms it can understand.<h1 id=essential>Essential</h1><p>The activity params described in this section are those which you will use almost all the time when configuring activities.<p>üëâ If you aren‚Äôt using one of these options with a <code>run</code> or <code>start</code> command, or otherwise in your named scenarios, double check that you aren‚Äôt missing something important.<h2 id=driver>driver</h2><ul><li><code>driver=&LTdriver></code><li><em>default</em>: unset<li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>Every activity can have a default driver. If provided, it will be used for any op template which does not have one directly assigned as an op field. For each op template in the workload, if no driver is set, an error is thrown.<p>As each activity can have multiple op templates, and each op template can have its own driver, the available activity params for a workload are determined by the superset of valid params for all active drivers.<p>You can find out what drivers are available in nb5 with the <code>--list-drivers</code> option from <a href=https://docs.nosqlbench.io/reference/cli/core-activity-params/options.md#discovery-options>discovery options</a>. You can then get details on what each of these drivers allow with <code>nb5 help &LTdriver></code>.<p>The driver selection for an op template determines the valid constructions for the op template. For example:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span style=color:#65737e># file test.yaml
</span><span style=color:#bf616a>ops</span><span>:
</span><span>  </span><span style=color:#bf616a>op1</span><span>:
</span><span>    </span><span style=color:#bf616a>op</span><span>:
</span><span>      </span><span style=color:#bf616a>driver</span><span>: </span><span style=color:#a3be8c>stdout
</span><span>      </span><span style=color:#bf616a>stmt</span><span>: "</span><span style=color:#a3be8c>example {{Identity()}}</span><span>"
</span></code></pre><p>If an activity were started up which references this file as <code>workload=test.yaml</code>, then all the activity params recognized by the stdout driver would be valid, in addition to the core activity params documented in this section.<p><em>examples</em><ul><li><code>driver=stdout</code> - set the default driver to <code>stdout</code></ul><h2 id=workload>workload</h2><ul><li><p><em>default</em>: unset, <em>required</em>: one of <code>workload=</code> or <code>op=</code> or <code>stmt=</code>, <em>dynamic</em>: no</p><li><p><code>workload=&LTfilename></code> where filename is a <a href=https://yaml.org/ rel=noopener target=_blank>YAML</a>, <a href=https://json.org/ rel=noopener target=_blank>JSON</a>, or <a href=https://jsonnet.org/ rel=noopener target=_blank>Jsonnet</a> file with matching extension. If the extension is missing, then it is presumed to be a yaml file. Workload filenames are resolved on the local filesystem first, then from the files which are bundled into the nosqlbench binary or jar.</p><li><p><code>workload="&LTURL>"</code> where <a href=https://en.wikipedia.org/wiki/URL rel=noopener target=_blank>URL</a> with an valid <a href=https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL#scheme rel=noopener target=_blank>scheme</a>, like http, https, or <a href=https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html#accessing-a-bucket-using-S3-format rel=noopener target=_blank>S3</a>. S3 support has been added directly, so you can use these URIs so long as you have a valid AWS configuration.</p><li><p><code>workload="&LTJSON Object>"</code> where the param value is a JSON object starting with <code>{</code>. Escaping might be necessary for some characters when using this on the command line.</p> <ul><li>example: <code>workload='{"bindings":{"b1":"NumberNameToString()"},"op":"testing {b1}"}'</code></ul></ul><p>The workload param tells an activity where to load its <a href=../../tutorials/workload-basics/_index.md>workload template</a> from. The workload template is a collection of op templates which are blueprints for the operations that an activity runs.<p>If the file is a Jsonnet file (by extension), then a local jsonnet interpreter will be run against it before being handled as above. Within this evaluation context, all provided activity parameters are available as external variables and accessible via the standard Jsonnet APIs, specifically <a href=https://jsonnet.org/ref/stdlib.html#extVar rel=noopener target=_blank>std.extVar(str)</a>. For doing robust data type conversion, use <a href=https://jsonnet.org/ref/stdlib.html#parseJson rel=noopener target=_blank>std.parseJson(str)</a> by default.<h2 id=op>op</h2><p>This is a serialized version of an operation to be parsed as an op template. It can be in one of a few supported forms: JSON, as indicated by a leading <code>{</code> character, or a simple params map, which is indicated by interior <code>name=value</code> assignments. If you want to provide a simpler form which is representative a string statement, use the stmt form below.<h2 id=stmt>stmt</h2><p>This is a short form version of an op template which contains a single op field for <code>stmt</code>, which is the default form for any <em>statement-oriented</em> operations in common protocols like CQL, SQL, stdout, or similar. If you need to provide more op template details than this form allows, then either use the <em>op</em> form above, or provide a full workload.<h2 id=tags>tags</h2><ul><li><code>tags=&LTfilterspec></code><li><em>default</em>: unset<li><em>required</em>: no<li><em>dynamic</em> : no</ul><p>Tags are used to filter the set of op templates presented for sequencing in an activity. Each op template has a set of tags, which include two auto-tags that are provided by the runtime:<ul><li><code>block</code> - the block name that contains the op template. All op templates are part of some block, even if they are configured at the root of a document. There is a virtual block named <code>block0</code> which all of the root-level op templates are assigned to.<li><code>name</code> - a unique name for the op template within the workload template. This is a concatenation of the block name, two dashes (‚Äì) and the base op template name. For example, an op in <code>block0</code> with a base name of <code>opexample2</code> would be <code>block0--opexample2</code>. This allows for regex matching that can be globally distinct within a workload.</ul><p>The rules for tag filtering are explained in depth in the <a href=../../tutorials/workload-basics/05-op-tags.md>Op Tags</a> of the <a href=../../tutorials/workload-basics/_index.md>Workload Basics</a> tutorial.<h2 id=threads>threads</h2><ul><li><code>threads=&LTthreads></code><li><em>default</em>: 1<li><em>required</em>: no<li><em>dynamic</em>: yes</ul><p>You should set the <em>threads</em> parameter when you need to ramp up a workload.<p>This controls how many threads will be started up for an activity to run its cycles with.<p><em>default value</em> : For now, the default is simply <em>1</em>. Users must be aware of this setting and adjust it to a reasonable value for their workloads.<p><code>threads=auto</code> : Set the number of threads to 10x the number of cores in your system. There is no distinction here between full cores and hardware threads. This is generally a reasonable number of threads to tap into the processing power of a client system.<p><code>threads=__x</code> : When you set <code>threads=5x</code> or <code>threads=10x</code>, you will Set the number of threads to some multiplier of the logical CPUs in the local system.<p>A good rule of thumb for setting threads for maximum effect is to set it relatively high, such as 10XvCPU when running synchronous workloads (when not providing the async parameter), and to 5XvCPU for all async workloads. Variation in system dynamics make it difficult to peg an ideal number, so experimentation is encouraged while you dial in your settings initially.<p><em>examples</em><ul><li><code>threads=30x</code> - set the number of threads in an activity to 30 √ó cores.<li><code>threads=auto</code> - set the number of threads in an activity to 10 √ó cores.<li><code>threads=10</code> - set the number of threads in an activity to 10.</ul><h2 id=cycles>cycles</h2><ul><li><code>cycles=&LTcycle count></code><li><code>cycles=&LTcycle min>..&LTcycle max></code><li><em>default</em>: 1<li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>The cycles parameter determines the starting and ending point for an activity. It determines the range of values which will act as seed values for each operation. For each cycle of the activity, a statement is built from a statement template and executed as an operation.<p>For each cycle in an activity, the cycle is used as the input to the binding functions. This allows you to create numerical relationships between all of the data used in your activity.<p>If you do not set the cycles parameter, then it will automatically be set to the size of the sequence. The sequence is simply the length of the op sequence that is constructed from the active op templates and ratios in your activity.<p>You <em>should</em> set the cycles for every activity except for schema-like activities, or activities which you run just as a sanity check of active statements.<p>In the <code>cycles=&LTcycle count></code> version, the count indicates the total number of cycles, and is equivalent to <code>cycles=0..&LTcycle max></code>. In both cases, the max value is not the actual number of the last cycle. This is because all cycle parameters define a closed-open interval. In other words, the minimum value is either zero by default or the specified minimum value, but the maximum value is the first value <em>not</em> included in the interval. This means that you can easily stack intervals over subsequent runs while knowing that you will cover all logical cycles without gaps or duplicates. For example, given <code>cycles=1000</code> and then <code>cycles=1000..2000</code>, and then <code>cycles=2000..5K</code>, you know that all cycles between 0 (inclusive) and 5000 (exclusive) have been specified.<p><em>examples</em><ul><li><code>cycles=500</code> - run an activity over cycles [0,500), including 0 and 499, but not 500.<li><code>cycles=20M</code> - run an activity over cycles [0,20000000).<li><code>cycles=2k..3k</code> - run an activity over cycles [2000,3000).</ul><h2 id=recycles>recycles</h2><ul><li><code>recycles=&LTrecycle count></code><li><code>recycles=&LTrecycle min>..&LTrecycle max></code><li><em>default</em>: 1<li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>This is another layer of iteration around the cycles values. With this, it is easy to set any activity to repeat arbitrarily, or to have multiple specific iterations of some base workload. Recycles is effectively the higher-order ordinal which wraps repeated use of the same cycles interval. The combination of cycle and recycle is mathematically consistent. If you set <code>recycles=1 cycles=1</code>, then you will have one total cycle executed. If you set <code>recycles=10 cycles=10</code>, then you will have 100. If either of them is effectively set to zero, then no cycles will occur.<p>They are also both interval-specific, so canonically, <code>recycles=37..39 cycles=7..11</code> is distinct from <code>recycles=39..41 cycles=7..11</code>, although this is of limited utility until recycles is hoisted further into op execution. In the future, this value may be used, for example, to bracket instancing of metrics around specific recycle values, so that metrics are collected distinctly for each <em>recycle</em>.<h2 id=errors>errors</h2><ul><li><code>errors=&LTerror handler spec></code><li><em>default</em>: <code>errors=stop</code><li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>This activity param allows you to specify what happens when an exception is thrown during execution of an operation (within a cycle). You can configure any named exception to be handled with any of the available handler verbs in the order your choosing.<p>üëâ By default, any single error in any operation will cause your test to stop. This is not generally what you want to do for significant test scenarios.<p>You generally want to configure this so that you can run an activity as long as needed without a single error stopping the whole thing. However, it is important for users to know exactly how this is configured, so it is up to the user to set this appropriately.<p>The detailed configuration of error handlers is covered in <a href=../../guides/workload-design/error-handlers.md>error handlers</a><h2 id=maxtries>maxtries</h2><ul><li><code>maxtries=&LTmaxtries></code><li><em>default</em>: <code>maxtries=10</code><li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>This sets the number of times an operation will be retried in the event that it fails and the error handler is set to retry it.<h2 id=labels>labels</h2><ul><li><code>labels=&LTlabel_key>:&LTlabel_value>[,...]</code><li><em>default</em>: ``<li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>The labels provided in this form will be appended to the labels for this activity, used in metrics reporting and annotations.<h1 id=diagnostic>Diagnostic</h1><p>These params allow you to see more closely how an activity works for the purpose of troubleshooting or test verification.<h2 id=dryrun>dryrun</h2><ul><li><code>dryrun=&LTstepname></code><li><em>default</em>: unset<li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>This option is checked at various stages of activity initialization in order to modify the way an activity runs. Some of the dryrun options stop an activity and dump out a summary of some specific step. Others wrap normal mechanisms in a <a href=https://en.wikipedia.org/wiki/NOP_(code) rel=noopener target=_blank>noop</a> in order to exercise other parts of the machinery at full speed.<p><em>examples</em><ul><li><code>dryrun=jsonnet</code> - When rendering a jsonnet workload, dump the result to the console and exit.<li><code>dryrun=op</code> - Wrap the operation in a noop, to measure core nb5 execution speed without invoking operations.</ul><h1 id=metrics>Metrics</h1><h2 id=alias>alias</h2><ul><li><code>alias=&LTalias></code><li><em>default</em>: inferred from yaml, or ‚ÄòUNSET‚Äô<li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>You <em>should</em> set the <em>alias</em> parameter when you have multiple activities, when you want to name metrics per-activity, or when you want to control activities via scripting.<p>Each activity can be given a symbolic name known as an <em>alias</em>. It is good practice to give all your activities an alias, since this determines the named used in logging, metrics, and even scripting control.<p><em>default value</em> : The name of any provided YAML filename is used as the basis for the default alias. Otherwise, the activity type name is used. This is a convenience for simple test scenarios only.<h2 id=instrument>instrument</h2><ul><li><code>instrument=&LTboolean></code><li><em>default</em>: false<li>_required: no<li><em>dynamic</em>: no</ul><p>This activity param allows you to set the default value for the instrument op field.<h2 id=hdr-digits>hdr_digits</h2><ul><li><code>hdr_digits=&LTnum digits></code><li><em>default</em>: <code>4</code><li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>This parameter determines the number of significant digits used in all HDR histograms for metrics collected from this activity. The default of 4 allows 4 significant digits, which means <em>up to</em> 10000 distinct histogram buckets per named metric, per histogram interval. This does not mean that there <em>will be</em> 10000 distinct buckets, but it means there could be if there is significant volume and variety in the measurements.<p>If you are running a scenario that creates many activities, then you can set <code>hdr_digits=1</code> on some of them to save client resources.<h1 id=customization>Customization</h1><h2 id=cyclerate>cyclerate</h2><ul><li><code>cyclerate=&LTcycle per second></code><li><code>cyclerate=&LTcycles per second>,&LTburst_ratio></code><li><em>default</em>: unset<li><em>required</em>: no<li><em>dynamic</em>: yes</ul><p>The cyclerate parameter sets a maximum op rate for individual cycles within the activity, across the whole activity, irrespective of how many threads are active.<p>üëâ The cyclerate is a rate limiter, and can thus only throttle an activity to be slower than it would otherwise run. Rate limiting is also an invasive element in a workload, and will always come at a cost. For extremely high throughput testing, consider carefully whether your testing would benefit more from concurrency-based throttling such as adjust the number of threads.<p>When the cyclerate parameter is provided, two additional metrics are tracked: the wait time and the response time. See timing terminology for more details.<p>When you try to set very high cyclerate values on systems with many cores, the performance will degrade. Be sure to use dryrun features to test this if you think it is a limitation. You can always set the rate high enough that the rate limiter can‚Äôt sustain. This is like telling it to get in the way and then get out of the way even faster. This is just the nature of this type of rate limiter.<p>There are plans to make the rate limiter adaptive across a wider variety of performance scenarios, which will improve this.<p><em>examples</em><ul><li><code>cyclerate=1000</code> - set the cycle rate limiter to 1000 ops/s and a default burst ratio of 1.1.<li><code>cyclerate=1000,1.0</code> - same as above, but with burstrate set to 1.0 (use it or lose it, not usually desired)<li><code>cyclerate=1000,1.5</code> - same as above, with burst rate set to 1.5 (aka 50% burst allowed)</ul><p><strong>burst ratio</strong><p>This is only an optional part of the cyclerate as shown in examples above. If you do not specify it when you initialize a cyclerate, then it defaults 1.1. The burst ratio is only valid as part of a rate limit and can not be specified by itself.<ul><li><em>default</em>: <code>1.1</code><li><em>dynamic</em>: yes</ul><p>The NoSQLBench rate limiter provides a sliding scale between strict rate limiting and average rate limiting. The difference between them is controlled by a <em>burst ratio</em> parameter. When the burst ratio is 1.0 (burst up to 100% relative rate), the rate limiter acts as a strict rate limiter, disallowing faster operations from using time that was previously forfeited by prior slower operations. This is a ‚Äúuse it or lose it‚Äù mode that means things like GC events can steal throughput from a running client as a necessary effect of losing time in a strict timing sense.<p>When the burst ratio is set to higher than 1.0, faster operations may recover lost time from previously slower operations. For example, a burst ratio of 1.3 means that the rate limiter will allow bursting up to 130% of the base rate, but only until the average rate is back to 100% relative speed. This means that any valleys created in the actual op rate of the client can be converted into plateaus of throughput above the strict rate, but only at a speed that fits within (op rate * burst ratio). This allows for workloads to approximate the average target rate over time, with controllable bursting rates. This ability allows for near-strict behavior while allowing clients to still track truer to rate limit expectations, so long as the overall workload is not saturating resources.<p>üëâ The default burst ratio of 1.1 makes testing results slightly more stable on average, but can also hide some short-term slow-downs in system throughput. It is set at the default to fit most tester‚Äôs expectations for averaging results, but it may not be strict enough for your testing purposes. However, a strict setting of 1.0 nearly always adds cold/startup time to the result, so if you are testing for steady state, be sure to account for this across test runs.<h2 id=striderate>striderate</h2><ul><li><code>striderate=&LTstrides per second></code><li><code>striderate=&LTstrides per second>,&LTburst_ratio></code><li><em>default</em>: unset<li><em>required</em>: no<li><em>dynamic</em>: yes</ul><p>The <code>striderate</code> parameter allows you to limit the start of a stride according to some rate. This works almost exactly like the cyclerate parameter, except that it blocks a whole group of operations from starting instead of a single operation. The striderate can use a burst ratio just as the cyclerate.<p>This sets the target rate for strides. In NoSQLBench, a stride is a group of operations that are dispatched and executed together within the same thread. This is useful, for example, to emulate application behaviors in which some outside request translates to multiple internal requests. It is also a way to optimize a client runtime for more efficiency and throughput. The stride rate limiter applies to the whole activity irrespective of how many threads it has.<p><strong>WARNING:</strong> When using the cyclerate and striderate options together, operations are delayed based on both rate limiters. If the relative rates are not synchronised with the size of a stride, then one rate limiter will artificially throttle the other. Thus, it usually doesn‚Äôt make sense to use both of these settings in the same activity.<h2 id=stride>stride</h2><ul><li><code>stride=&LTstride></code><li><em>default</em>: same as op sequence length<li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>Usually, you don‚Äôt want to provide a setting for stride, but it is still important to understand what it does. Within NoSQLBench, each time a thread needs to allocate a set of cycles to run, it takes a contiguous range of values from an activity-wide source, usually an atomic sequence. Thus, the stride is the unit of micro-batching within NoSQLBench. It also means that you can use stride to optimize a workload by setting the value higher than the default. For example if you are running a single-statement workload at a very high rate, it doesn‚Äôt make sense for threads to allocate one op at a time from a shared atomic value. You can simply set <code>stride=1000</code> to cause (ballpark estimation) about 1000X less internal contention. The stride is initialized to the calculated sequence length. The sequence length is simply the number of operations in the op sequence that is planned from your active statements and their ratios.<p>You usually do not want to set the stride directly. If you do, make sure it is a multiple of what it would normally be set to if you need to ensure that sequences are not divided up differently. This can be important when simulating the access patterns of applications.<p><em>examples</em><ul><li><code>stride=1000</code> - set the stride to 1000</ul><h2 id=seq>seq</h2><ul><li><code>seq=&LTbucket|concat|interval></code><li><em>default</em>: <code>seq=bucket</code><li><em>required</em>: no<li><em>dynamic</em>: no</ul><p>The <code>seq=&LTbucket|concat|interval></code> parameter determines the type of sequencing that will be used to plan the op sequence. The op sequence is a look-up-table that is used for each stride to pick statement forms according to the cycle offset. It is simply the sequence of statements from your YAML that will be executed, but in a pre-planned, and highly efficient form.<p>An op sequence is planned for every activity. With the default ratio on every statement as 1, and the default bucket scheme, the basic result is that each active statement will occur once in the order specified. Once you start adding ratios to statements, the most obvious thing that you might expect will happen: those statements will occur multiple times to meet their ratio in the op mix. You can customize the op mix further by changing the seq parameter to concat or interval.<p>üëâ The op sequence is a look-up table of op templates, <em>not</em> individual statements or operations. Thus, the cycle still determines the uniqueness of an operation as you would expect. For example, if statement form ABC occurs 3x per sequence because you set its ratio to 3, then each of these would manifest as a distinct operation with fields determined by distinct cycle values.<p>There are three schemes to pick from:<p><strong>bucket</strong><p>This is a round-robin planner which draws operations from buckets in circular fashion, removing each bucket as it is exhausted. For example, the ratios A:4, B:2, C:1 would yield the sequence A B C A B A A. The ratios A:1, B5 would yield the sequence A B B B B B.<p><strong>concat</strong><p>This simply takes each statement template as it occurs in order and duplicates it in place to achieve the ratio. The ratios above (A:4, B:2, C:1) would yield the sequence A A A A B B C for the concat sequencer.<p><strong>interval</strong><p>This is arguably the most complex sequencer. It takes each ratio as a frequency over a unit interval of time, and apportions the associated operation to occur evenly over that time. When two operations would be assigned the same time, then the order of appearance establishes precedence. In other words, statements appearing first win ties for the same time slot. The ratios A:4 B:2 C:1 would yield the sequence A B C A A B A. This occurs because, over the unit interval (0.0,1.0), A is assigned the positions <code>A: 0.0, 0.25, 0.5, 0.75</code>, B is assigned the positions <code>B: 0.0, 0.5</code>, and C is assigned position <code>C: 0.0</code>. These offsets are all sorted with a position-stable sort, and then the associated ops are taken as the order.<p>In detail, the rendering appears as <code>0.0(A), 0.0(B), 0.0(C), 0.25(A), 0.5(A), 0.5(B), 0.75(A)</code>, which yields <code>A B C A A B A</code> as the op sequence.<p>This sequencer is most useful when you want a stable ordering of operation from a rich mix of statement types, where each operation is spaced as evenly as possible over time, and where it is not important to control the cycle-by-cycle sequencing of statements.</article></main><footer><div class=c><nav class=tpad><div></div></nav><p>¬© <span id=year>2025</span> NoSQLBench Documentation<p>Powered by <a href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/jieiku/abridge/ target=_blank>Abridge</a></div></footer><span class=topout> <span class=topleft> </span><a title="Back to Top" class=top href=#><i class="svgs svgh angu"></i></a> </span>