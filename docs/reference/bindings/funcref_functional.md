+++
title = "flow functions"
description = "Auto-generated reference documentation for flow functions"
weight = 40
template = "docs-page.html"
date = 2025-11-13

[extra]
quadrant = "reference"
topic = "bindings"
category = "flow"
tags = ["auto-generated", "virtdata", "data-generation", "binding-functions"]
generator = "BundledMarkdownExporter"
source = "generated by export-docs"
+++


These functions help combine other functions into higher-order functions when needed.
## ConcatArray

This variant of Concat allows you to apply a string concatenation to a series of string produced by the provided functions. Each position of a delimiter will simply contain all generated values, although usually, you won't need more than one.

- `long -> ConcatArray(String: delimiter, int: size, String: template, Object[]...: functions) -> String`
  - *example:* `ConcatArray(',',5,'{{}}', NumberNameToString())`

## Expr

Allow for the use of arbitrary expressions according to the [MVEL](http://mvel.documentnode.com/) expression language. Variables that have been set by a Save function are available to be used in this function. The variable name `cycle` is reserved, and is always equal to the current input value. This is not the same in every case as the current cycle of an operation. It could be different if there are preceding functions which modify the input value.

- `long -> Expr(String: expr) -> int`

- `long -> Expr(String: expr) -> long`

- `long -> Expr(String: expr) -> String`

- `long -> Expr(String: expr) -> UUID`

- `int -> Expr(String: expr) -> int`

- `double -> Expr(String: expr) -> double`

- `long -> Expr(String: expr) -> Object`

## HashMix

Blends two functions with a domain of 0..Long.MAX_VALUE as the input interval, and a double output. The output value is interpolated between the output value of the two according to the mix function. When the mix function yields a value of 0.0, then the mix is turned _fully counter-clockwise_., or fully on the first provided function. When the value is 1.0, the mix is turned all the clockwise, or fully on the second provided function. If there are only two inner functions provided to HashMix, then it will default to sampling random mixes at a randomized sample point. In other words, the variates provided will be somewhere between the two curves on the unit interval. This is a simple way to sample between two curves by default. The yielded value will be greater than or equal to the lower of the two values at any point, and less than or equal to the greater of either. If a third parameter is provided to control the mix, then the mix can be set directly as a unit interval. (The dial goes from 0.0 to 1.0). Any double or float value here will suffice. You can use this when you want to have a test parameter that slews between two modeled shapes. You can alternately provide any other function which can be coerced to a LongToDouble function as a dynamic mix control. IFF such a function is provided, it must also be responsible for hashing the input value if pseudo-randomness is desired. If a fourth parameter is provided, the sample point can also be controlled. By default, the values on the provided curves will be sampled pseudo-randomly. However, a fourth parameter can override this just like the mix ratio. As well, if you provide a value or function to control the sample point, you are also responsible for any hashing needed to sample across the whole space of possible values. The flexibility of these two parameters provides a substantial amount of flexibility. You can, for example: - sample variates between two curves - sample variates at a selected morphing step between the curves - sample variates between two curves on a subsection of the unit interval - sample variates within a defined band gap of the two curves Blends two functions with a domain of 0..Long.MAX_VALUE as the input interval, and a double output. The output value is interpolated between the output value of the two according to the mix function. When the mix function yields a value of 0.0, then the mix is turned _fully counter-clockwise_., or fully on the first provided function. When the value is 1.0, the mix is turned all the clockwise, or fully on the second provided function. If there are only two inner functions provided to HashMix, then it will default to sampling random mixes at a randomized sample point. In other words, the variates provided will be somewhere between the two curves on the unit interval. This is a simple way to sample between two curves by default. The yielded value will be greater than or equal to the lower of the two values at any point, and less than or equal to the greater of either. If a third parameter is provided to control the mix, then the mix can be set directly as a unit interval. (The dial goes from 0.0 to 1.0). Any double or float value here will suffice. You can use this when you want to have a test parameter that slews between two modeled shapes. You can alternately provide any other function which can be coerced to a LongToDouble function as a dynamic mix control. IFF such a function is provided, it must also be responsible for hashing the input value if pseudo-randomness is desired. If a fourth parameter is provided, the sample point can also be controlled. By default, the values on the provided curves will be sampled pseudo-randomly. However, a fourth parameter can override this just like the mix ratio. As well, if you provide a value or function to control the sample point, you are also responsible for any hashing needed to sample across the whole space of possible values. The flexibility of these two parameters provides a substantial amount of flexibility. You can, for example: - sample variates between two curves - sample variates at a selected morphing step between the curves - sample variates between two curves on a subsection of the unit interval - sample variates within a defined band gap of the two curves

- `long -> HashMix(Object: curve1F, Object: curve2F, Object: mixPointF, Object: samplePointF) -> long`
  - *example:* `IntervalHashMix(Func1(),Func2())`
  - *yield samples between func1 and func2 values at some random random sample point x*
  - *example:* `IntervalHashMix(Func1(),Func2(),0.25d)`
  - *yield samples which are 25% from the sample values for func1 and func2 at some random sample point x*
  - *example:* `IntervalHashMix(Func1(),Func2(),HashRange(0.25d,0.75d)`
  - *yield samples between 25% and 75% from func1 to func2 values at some random sample point x*
  - *example:* `IntervalHashMix(Func1(),Func2(),0.0d,ScaledDouble())`
  - *access Func1 values as if it were the only one provided. ScaledDouble adds no randomization the input value, but it does map it to the sample domain of 0.0d-0.1d.*

- `long -> HashMix(Object: curve1F, Object: curve2F, Object: mixPointF) -> long`

- `long -> HashMix(Object: curve1F, Object: curve2F) -> long`

- `long -> HashMix(function.LongToDoubleFunction: f1, function.LongToDoubleFunction: f2) -> long`

- `long -> HashMix(Object: curve1F, Object: curve2F, Object: mixPointF, Object: samplePointF) -> double`
  - *example:* `HashMix(Func1(),Func2())`
  - *yield samples between func1 and func2 values at some random random sample point x*
  - *example:* `HashMix(Func1(),Func2(),0.25d)`
  - *yield samples which are 25% from the sample values for func1 and func2 at some random sample point x*
  - *example:* `HashMix(Func1(),Func2(),HashRange(0.25d,0.75d)`
  - *yield samples between 25% and 75% from func1 to func2 values at some random sample point x*
  - *example:* `HashMix(Func1(),Func2(),0.0d,ScaledDouble())`
  - *access Func1 values as if it were the only one provided. ScaledDouble adds no randomization the input value, but it does map it to the sample domain of 0.0d-0.1d.*

- `long -> HashMix(Object: curve1F, Object: curve2F, Object: mixPointF) -> double`

- `long -> HashMix(Object: curve1F, Object: curve2F) -> double`

- `long -> HashMix(function.LongToDoubleFunction: f1, function.LongToDoubleFunction: f2) -> double`

## IntFlow

Combine multiple IntUnaryOperators into a single function.

- `int -> IntFlow(function.IntUnaryOperator[]...: ops) -> int`

## LongFlow

Combine multiple LongUnaryOperators into a single function.

- `long -> LongFlow(function.LongUnaryOperator[]...: ops) -> long`
  - *example:* `LongFlow(Add(3),Mul(6))`
  - *Create an integer operator which adds 3 and multiplies the result by 6*

## StringFlow

Combine multiple String functions together into one function.

- `String -> StringFlow(function.Function<String,String>[]...: funcs) -> String`

